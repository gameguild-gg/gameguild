/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ChapterEntity
 */
export interface ChapterEntity {
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ChessLeaderboardResponseEntryDto
 */
export interface ChessLeaderboardResponseEntryDto {
    /**
     * 
     * @type {string}
     * @memberof ChessLeaderboardResponseEntryDto
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof ChessLeaderboardResponseEntryDto
     */
    'elo': number;
}
/**
 * 
 * @export
 * @interface ChessMatchRequestDto
 */
export interface ChessMatchRequestDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMatchRequestDto
     */
    'player1username': string;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchRequestDto
     */
    'player2username': string;
}
/**
 * 
 * @export
 * @interface ChessMatchResultDto
 */
export interface ChessMatchResultDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChessMatchResultDto
     */
    'players': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChessMatchResultDto
     */
    'moves': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'winner': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChessMatchResultDto
     */
    'draw': boolean;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'result': ChessMatchResultDtoResultEnum;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'reason': ChessMatchResultDtoReasonEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'cpuTime': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'finalFen': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'eloChange': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'elo': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'createdAt': string;
}

export const ChessMatchResultDtoResultEnum = {
    GameOver: 'GAME_OVER',
    Draw: 'DRAW',
    None: 'NONE'
} as const;

export type ChessMatchResultDtoResultEnum = typeof ChessMatchResultDtoResultEnum[keyof typeof ChessMatchResultDtoResultEnum];
export const ChessMatchResultDtoReasonEnum = {
    Checkmate: 'CHECKMATE',
    Stalemate: 'STALEMATE',
    InsufficientMaterial: 'INSUFFICIENT_MATERIAL',
    FiftyMoveRule: 'FIFTY_MOVE_RULE',
    ThreefoldRepetition: 'THREEFOLD_REPETITION',
    InvalidMove: 'INVALID_MOVE',
    None: 'NONE'
} as const;

export type ChessMatchResultDtoReasonEnum = typeof ChessMatchResultDtoReasonEnum[keyof typeof ChessMatchResultDtoReasonEnum];

/**
 * 
 * @export
 * @interface ChessMoveRequestDto
 */
export interface ChessMoveRequestDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMoveRequestDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ChessMoveRequestDto
     */
    'fen': string;
}
/**
 * 
 * @export
 * @interface CompetitionRunSubmissionReportDto
 */
export interface CompetitionRunSubmissionReportDto {
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'winsAsP1': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'winsAsP2': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'totalWins': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'pointsAsP1': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'pointsAsP2': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'totalPoints': number;
    /**
     * 
     * @type {UserDto}
     * @memberof CompetitionRunSubmissionReportDto
     */
    'user': UserDto;
}
/**
 * 
 * @export
 * @interface CourseEntity
 */
export interface CourseEntity {
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CourseEntity
     */
    'price': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseEntity
     */
    'subscriptionAccess': boolean;
    /**
     * 
     * @type {UserEntity}
     * @memberof CourseEntity
     */
    'author': UserEntity;
    /**
     * 
     * @type {Array<LectureEntity>}
     * @memberof CourseEntity
     */
    'lectures': Array<LectureEntity>;
    /**
     * 
     * @type {Array<ChapterEntity>}
     * @memberof CourseEntity
     */
    'chapters': Array<ChapterEntity>;
}
/**
 * 
 * @export
 * @interface LectureEntity
 */
export interface LectureEntity {
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface LocalSignInDto
 */
export interface LocalSignInDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface LocalSignInResponseDto
 */
export interface LocalSignInResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignInResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInResponseDto
     */
    'refreshToken': string;
    /**
     * 
     * @type {UserDto}
     * @memberof LocalSignInResponseDto
     */
    'user': UserDto;
}
/**
 * 
 * @export
 * @interface LocalSignUpDto
 */
export interface LocalSignUpDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MatchSearchRequestDto
 */
export interface MatchSearchRequestDto {
    /**
     * 
     * @type {string}
     * @memberof MatchSearchRequestDto
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof MatchSearchRequestDto
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSearchRequestDto
     */
    'pageId': number;
}
/**
 * 
 * @export
 * @interface MatchSearchResponseDto
 */
export interface MatchSearchResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'winner': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'lastState': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchSearchResponseDto
     */
    'players': Array<string>;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'passwordHash': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'passwordSalt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'facebookId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'googleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'appleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'linkedinId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'twitterId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'walletAddress': string;
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'elo': number;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserEntity
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordHash': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordSalt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'facebookId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'googleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'appleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'linkedinId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'twitterId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'walletAddress': string;
    /**
     * 
     * @type {number}
     * @memberof UserEntity
     */
    'elo': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLocalSignWithEmailOrUsername: async (localSignInDto: LocalSignInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localSignInDto' is not null or undefined
            assertParamExists('authControllerLocalSignWithEmailOrUsername', 'localSignInDto', localSignInDto)
            const localVarPath = `/auth/local/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localSignInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithGoogle: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailUsernamePassword: async (localSignUpDto: LocalSignUpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localSignUpDto' is not null or undefined
            assertParamExists('authControllerSignUpWithEmailUsernamePassword', 'localSignUpDto', localSignUpDto)
            const localVarPath = `/auth/local/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localSignUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserExists: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authControllerUserExists', 'user', user)
            const localVarPath = `/auth/userExists/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'token', token)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLocalSignWithEmailOrUsername(localSignInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLocalSignWithEmailOrUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignInWithGoogle(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignInWithGoogle(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignInWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalSignInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignUpWithEmailUsernamePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserExists(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUserExists(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerUserExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCurrentUser(options?: any): AxiosPromise<UserDto> {
            return localVarFp.authControllerGetCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerLocalSignWithEmailOrUsername(localSignInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithGoogle(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignInWithGoogle(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: any): AxiosPromise<LocalSignInResponseDto> {
            return localVarFp.authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserExists(user: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerUserExists(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerVerifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LocalSignInDto} localSignInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLocalSignWithEmailOrUsername(localSignInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignInWithGoogle(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignInWithGoogle(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LocalSignUpDto} localSignUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserExists(user: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerUserExists(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompetitionsApi - axios parameter creator
 * @export
 */
export const CompetitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerFindChessMatchResult: async (matchSearchRequestDto: MatchSearchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchSearchRequestDto' is not null or undefined
            assertParamExists('competitionControllerFindChessMatchResult', 'matchSearchRequestDto', matchSearchRequestDto)
            const localVarPath = `/Competitions/Chess/FindMatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchSearchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessLeaderboard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/Leaderboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessMatchResult: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('competitionControllerGetChessMatchResult', 'id', id)
            const localVarPath = `/Competitions/Chess/Match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetLatestChessCompetitionReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/LatestCompetitionReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerListChessAgents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/ListAgents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRequestChessMove: async (chessMoveRequestDto: ChessMoveRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chessMoveRequestDto' is not null or undefined
            assertParamExists('competitionControllerRequestChessMove', 'chessMoveRequestDto', chessMoveRequestDto)
            const localVarPath = `/Competitions/Chess/Move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chessMoveRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunChessMatch: async (chessMatchRequestDto: ChessMatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chessMatchRequestDto' is not null or undefined
            assertParamExists('competitionControllerRunChessMatch', 'chessMatchRequestDto', chessMatchRequestDto)
            const localVarPath = `/Competitions/Chess/RunMatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chessMatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunCompetition: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/RunCompetition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerSubmitChessAgent: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('competitionControllerSubmitChessAgent', 'file', file)
            const localVarPath = `/Competitions/Chess/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompetitionsApi - functional programming interface
 * @export
 */
export const CompetitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompetitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchSearchResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerFindChessMatchResult(matchSearchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerFindChessMatchResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetChessLeaderboard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChessLeaderboardResponseEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetChessLeaderboard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetChessLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetChessMatchResult(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChessMatchResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetChessMatchResult(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetChessMatchResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetLatestChessCompetitionReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompetitionRunSubmissionReportDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetLatestChessCompetitionReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetLatestChessCompetitionReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerListChessAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerListChessAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerListChessAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRequestChessMove(chessMoveRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRequestChessMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRunChessMatch(chessMatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRunChessMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRunCompetition(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRunCompetition(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRunCompetition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerSubmitChessAgent(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerSubmitChessAgent(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerSubmitChessAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompetitionsApi - factory interface
 * @export
 */
export const CompetitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompetitionsApiFp(configuration)
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: any): AxiosPromise<Array<MatchSearchResponseDto>> {
            return localVarFp.competitionControllerFindChessMatchResult(matchSearchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessLeaderboard(options?: any): AxiosPromise<Array<ChessLeaderboardResponseEntryDto>> {
            return localVarFp.competitionControllerGetChessLeaderboard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessMatchResult(id: string, options?: any): AxiosPromise<ChessMatchResultDto> {
            return localVarFp.competitionControllerGetChessMatchResult(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetLatestChessCompetitionReport(options?: any): AxiosPromise<Array<CompetitionRunSubmissionReportDto>> {
            return localVarFp.competitionControllerGetLatestChessCompetitionReport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerListChessAgents(options?: any): AxiosPromise<void> {
            return localVarFp.competitionControllerListChessAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.competitionControllerRequestChessMove(chessMoveRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.competitionControllerRunChessMatch(chessMatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunCompetition(options?: any): AxiosPromise<void> {
            return localVarFp.competitionControllerRunCompetition(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerSubmitChessAgent(file: File, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.competitionControllerSubmitChessAgent(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompetitionsApi - object-oriented interface
 * @export
 * @class CompetitionsApi
 * @extends {BaseAPI}
 */
export class CompetitionsApi extends BaseAPI {
    /**
     * 
     * @param {MatchSearchRequestDto} matchSearchRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerFindChessMatchResult(matchSearchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetChessLeaderboard(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetChessLeaderboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetChessMatchResult(id: string, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetChessMatchResult(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetLatestChessCompetitionReport(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetLatestChessCompetitionReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerListChessAgents(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerListChessAgents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChessMoveRequestDto} chessMoveRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRequestChessMove(chessMoveRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChessMatchRequestDto} chessMatchRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRunChessMatch(chessMatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRunCompetition(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRunCompetition(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerSubmitChessAgent(file: File, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerSubmitChessAgent(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentControllerCreateEmptyCourse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/course/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentControllerCreateEmptyCourse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentControllerCreateEmptyCourse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentControllerCreateEmptyCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentControllerCreateEmptyCourse(options?: any): AxiosPromise<CourseEntity> {
            return localVarFp.contentControllerCreateEmptyCourse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentControllerCreateEmptyCourse(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentControllerCreateEmptyCourse(options).then((request) => request(this.axios, this.basePath));
    }
}



