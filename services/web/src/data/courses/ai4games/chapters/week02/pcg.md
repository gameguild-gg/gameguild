<section>
  <h1>Procedural Content Generation</h1>
  <h2>Week 2</h2>
  <h5>By: Alex Tolstenko</h5>
</section>
<section>
  <h2>What is Procedural Content Generation (PCG)?</h2>
  <ul>
    <li><strong>Definition</strong>: The algorithmic creation of game content with limited or no human input.</li>
  </ul>
</section>
<section>
  <ul>
    <li>
      <strong>Purpose</strong>:
      <ul>
        <li>Increase replayability.</li>
        <li>Reduce development costs.</li>
        <li>Enable scalability for large or dynamic worlds.</li>
      </ul>
    </li>
    <li>
      <strong>Examples</strong>:
      <ul>
        <li>Terrain and map generation.</li>
        <li>Dungeon layouts and level.</li>
        <li>Weapon or character designs.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Benefits of PCG</h2>
  <ul>
    <li><strong>Replayability</strong>: Unique experiences in every playthrough.</li>
    <li><strong>Resource Efficiency</strong>: Save time and effort for developers.</li>
    <li><strong>Scalability</strong>: Create vast worlds or levels dynamically.</li>
    <li><strong>Player Engagement</strong>: Surprises and challenges through variability.</li>
  </ul>
</section>
<section>
  <h2>Common PCG Techniques</h2>
  <ul>
    <li>
      <strong>Noise Functions</strong>:
      <ul>
        <li>Examples: Perlin Noise, Simplex Noise.</li>
        <li>Used for: Terrain generation, textures.</li>
      </ul>
    </li>
    <li>
      <strong>Rule-Based Systems</strong>:
      <ul>
        <li>Define rules to combine elements procedurally.</li>
        <li>Example: Roguelike dungeon generation.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>
      <strong>Agent-Based Systems</strong>:
      <ul>
        <li>Agents simulate behavior to shape content.</li>
        <li>Example: Road generation in open-world games.</li>
      </ul>
    </li>
    <li>
      <strong>Grammar-Based Generation</strong>:
      <ul>
        <li>Define grammars to generate content.</li>
        <li>Example: City layouts, storylines.</li>
      </ul>
    </li>
    <li>
      <strong>Machine Learning</strong>:
      <ul>
        <li>Train models to generate game content.</li>
        <li>Example: Neural networks for level design.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Use Cases in Games</h2>
  <ul>
    <li>
      <strong>World Generation</strong>:
      <ul>
        <li>Example: Minecraft’s infinite terrain.</li>
      </ul>
    </li>
    <li>
      <strong>Dungeon Crawlers</strong>:
      <ul>
        <li>Example: Diablo’s randomized levels.</li>
      </ul>
    </li>
    <li>
      <strong>Character Customization</strong>:
      <ul>
        <li>Example: Spore’s creature editor.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Use Cases in Games</h2>
  <ul>
    <li>
      <strong>Narrative Generation</strong>:
      <ul>
        <li>Example: AI-driven storylines in AI Dungeon.</li>
      </ul>
    </li>
    <li>
      <strong>Item Generation</strong>:
      <ul>
        <li>Example: Randomized loot in Borderlands.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Challenges in PCG</h2>
  <ul>
    <li><strong>Quality Control</strong>: Ensuring generated content meets design expectations.</li>
    <li><strong>Balance</strong>: Avoiding overpowered or underwhelming outcomes.</li>
    <li><strong>Complexity</strong>: Designing algorithms that produce meaningful results.</li>
    <li><strong>Player Expectations</strong>: Balancing randomness with coherence and fairness.</li>
  </ul>
</section>
<section>
  <h2>Best Practices for PCG</h2>
  <ul>
    <li><strong>Define Clear Goals</strong>: Know what you want the algorithm to achieve.</li>
    <li><strong>Test Iteratively</strong>: Frequently test and refine the system.</li>
    <li><strong>Combine Techniques</strong>: Use multiple methods to achieve complex results.</li>
</ul>
</section>
<section>
  <h2>Best Practices for PCG</h2>
  <ul>
    <li><strong>Control Randomness</strong>: Add constraints to ensure coherent outcomes.</li>
    <li><strong>Engage Players</strong>: Allow players to influence the generated content.</li>
  </ul>
</section>
<section>
  <h2>Tools and Frameworks</h2>
  <ul>
    <li>
      <strong>Unity</strong>:
      <ul>
        <li>Assets like Gaia, MapMagic for terrain generation.</li>
      </ul>
    </li>
    <li>
      <strong>Unreal Engine</strong>:
      <ul>
        <li>Procedural tools and Blueprints.</li>
      </ul>
    </li>
    <li>
      <strong>Standalone Libraries</strong>:
      <ul>
        <li>Noise libraries: FastNoise, LibNoise.</li>
        <li>PCG libraries: Dungeon Architect.</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Future of PCG</h2>
  <ul>
    <li><strong>AI Integration</strong>: Advanced AI creating more sophisticated content.</li>
    <li><strong>Player-Centric Design</strong>: Adaptive PCG tailored to individual player preferences.</li>
    <li><strong>Hybrid Approaches</strong>: Combining procedural and handcrafted content for balance.</li>
  </ul>
</section>
<section>
  <h2>Summary</h2>
  <ul>
    <li>PCG is a powerful tool to enhance games through dynamic and scalable content.</li>
    <li>Balancing randomness, coherence, and player engagement is key.</li>
    <li>Emerging AI technologies are shaping the future of PCG.</li>
  </ul>
</section>