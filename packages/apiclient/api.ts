/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ChapterEntity
 */
export interface ChapterEntity {
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof ChapterEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof ChapterEntity
     */
    'editors': Array<UserEntity>;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'visibility': ChapterEntityVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof ChapterEntity
     */
    'thumbnail': string;
    /**
     * 
     * @type {number}
     * @memberof ChapterEntity
     */
    'order': number;
    /**
     * 
     * @type {CourseEntity}
     * @memberof ChapterEntity
     */
    'course': CourseEntity;
    /**
     * 
     * @type {Array<LectureEntity>}
     * @memberof ChapterEntity
     */
    'lectures': Array<LectureEntity>;
}

export const ChapterEntityVisibilityEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Future: 'FUTURE',
    Pending: 'PENDING',
    Private: 'PRIVATE',
    Trash: 'TRASH'
} as const;

export type ChapterEntityVisibilityEnum = typeof ChapterEntityVisibilityEnum[keyof typeof ChapterEntityVisibilityEnum];

/**
 * 
 * @export
 * @interface ChessLeaderboardResponseEntryDto
 */
export interface ChessLeaderboardResponseEntryDto {
    /**
     * 
     * @type {string}
     * @memberof ChessLeaderboardResponseEntryDto
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof ChessLeaderboardResponseEntryDto
     */
    'elo': number;
}
/**
 * 
 * @export
 * @interface ChessMatchRequestDto
 */
export interface ChessMatchRequestDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMatchRequestDto
     */
    'player1username': string;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchRequestDto
     */
    'player2username': string;
}
/**
 * 
 * @export
 * @interface ChessMatchResultDto
 */
export interface ChessMatchResultDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChessMatchResultDto
     */
    'players': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChessMatchResultDto
     */
    'moves': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'winner': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChessMatchResultDto
     */
    'draw': boolean;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'result': ChessMatchResultDtoResultEnum;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'reason': ChessMatchResultDtoReasonEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'cpuTime': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'finalFen': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'eloChange': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChessMatchResultDto
     */
    'elo': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ChessMatchResultDto
     */
    'createdAt': string;
}

export const ChessMatchResultDtoResultEnum = {
    GameOver: 'GAME_OVER',
    Draw: 'DRAW',
    None: 'NONE'
} as const;

export type ChessMatchResultDtoResultEnum = typeof ChessMatchResultDtoResultEnum[keyof typeof ChessMatchResultDtoResultEnum];
export const ChessMatchResultDtoReasonEnum = {
    Checkmate: 'CHECKMATE',
    Stalemate: 'STALEMATE',
    InsufficientMaterial: 'INSUFFICIENT_MATERIAL',
    FiftyMoveRule: 'FIFTY_MOVE_RULE',
    ThreefoldRepetition: 'THREEFOLD_REPETITION',
    InvalidMove: 'INVALID_MOVE',
    None: 'NONE'
} as const;

export type ChessMatchResultDtoReasonEnum = typeof ChessMatchResultDtoReasonEnum[keyof typeof ChessMatchResultDtoReasonEnum];

/**
 * 
 * @export
 * @interface ChessMoveRequestDto
 */
export interface ChessMoveRequestDto {
    /**
     * 
     * @type {string}
     * @memberof ChessMoveRequestDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ChessMoveRequestDto
     */
    'fen': string;
}
/**
 * 
 * @export
 * @interface CompetitionRunEntity
 */
export interface CompetitionRunEntity {
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CompetitionRunSubmissionReportEntity
 */
export interface CompetitionRunSubmissionReportEntity {
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'winsAsP1': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'winsAsP2': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'totalWins': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'pointsAsP1': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'pointsAsP2': number;
    /**
     * 
     * @type {number}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'totalPoints': number;
    /**
     * 
     * @type {CompetitionRunEntity}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'run': CompetitionRunEntity;
    /**
     * 
     * @type {CompetitionSubmissionEntity}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'submission': CompetitionSubmissionEntity;
    /**
     * 
     * @type {UserEntity}
     * @memberof CompetitionRunSubmissionReportEntity
     */
    'user': UserEntity;
}
/**
 * 
 * @export
 * @interface CompetitionSubmissionEntity
 */
export interface CompetitionSubmissionEntity {
    /**
     * 
     * @type {string}
     * @memberof CompetitionSubmissionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionSubmissionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompetitionSubmissionEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CourseEntity
 */
export interface CourseEntity {
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof CourseEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof CourseEntity
     */
    'editors': Array<UserEntity>;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'visibility': CourseEntityVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof CourseEntity
     */
    'thumbnail': string;
    /**
     * 
     * @type {number}
     * @memberof CourseEntity
     */
    'price': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseEntity
     */
    'subscriptionAccess': boolean;
    /**
     * 
     * @type {UserEntity}
     * @memberof CourseEntity
     */
    'author': UserEntity;
    /**
     * 
     * @type {Array<LectureEntity>}
     * @memberof CourseEntity
     */
    'lectures': Array<LectureEntity>;
    /**
     * 
     * @type {Array<ChapterEntity>}
     * @memberof CourseEntity
     */
    'chapters': Array<ChapterEntity>;
}

export const CourseEntityVisibilityEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Future: 'FUTURE',
    Pending: 'PENDING',
    Private: 'PRIVATE',
    Trash: 'TRASH'
} as const;

export type CourseEntityVisibilityEnum = typeof CourseEntityVisibilityEnum[keyof typeof CourseEntityVisibilityEnum];

/**
 * 
 * @export
 * @interface EditorRequestDto
 */
export interface EditorRequestDto {
    /**
     * 
     * @type {string}
     * @memberof EditorRequestDto
     */
    'id': string;
    /**
     * 
     * @type {IdDto}
     * @memberof EditorRequestDto
     */
    'editor': IdDto;
}
/**
 * 
 * @export
 * @interface EmailDto
 */
export interface EmailDto {
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface EthereumSigninChallengeRequestDto
 */
export interface EthereumSigninChallengeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof EthereumSigninChallengeRequestDto
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface EthereumSigninChallengeResponseDto
 */
export interface EthereumSigninChallengeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof EthereumSigninChallengeResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EthereumSigninValidateRequestDto
 */
export interface EthereumSigninValidateRequestDto {
    /**
     * 
     * @type {string}
     * @memberof EthereumSigninValidateRequestDto
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof EthereumSigninValidateRequestDto
     */
    'signature': string;
}
/**
 * @type GetManyBaseProjectControllerProjectEntity200Response
 * @export
 */
export type GetManyBaseProjectControllerProjectEntity200Response = Array<ProjectEntity> | GetManyProjectEntityResponseDto;

/**
 * @type GetManyBaseProjectVersionControllerProjectVersionEntity200Response
 * @export
 */
export type GetManyBaseProjectVersionControllerProjectVersionEntity200Response = Array<ProjectVersionEntity> | GetManyProjectVersionEntityResponseDto;

/**
 * 
 * @export
 * @interface GetManyProjectEntityResponseDto
 */
export interface GetManyProjectEntityResponseDto {
    /**
     * 
     * @type {Array<ProjectEntity>}
     * @memberof GetManyProjectEntityResponseDto
     */
    'data': Array<ProjectEntity>;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectEntityResponseDto
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectEntityResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectEntityResponseDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectEntityResponseDto
     */
    'pageCount': number;
}
/**
 * 
 * @export
 * @interface GetManyProjectVersionEntityResponseDto
 */
export interface GetManyProjectVersionEntityResponseDto {
    /**
     * 
     * @type {Array<ProjectVersionEntity>}
     * @memberof GetManyProjectVersionEntityResponseDto
     */
    'data': Array<ProjectVersionEntity>;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectVersionEntityResponseDto
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectVersionEntityResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectVersionEntityResponseDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetManyProjectVersionEntityResponseDto
     */
    'pageCount': number;
}
/**
 * 
 * @export
 * @interface IdDto
 */
export interface IdDto {
    /**
     * 
     * @type {string}
     * @memberof IdDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface LectureEntity
 */
export interface LectureEntity {
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof LectureEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof LectureEntity
     */
    'editors': Array<UserEntity>;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'visibility': LectureEntityVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof LectureEntity
     */
    'thumbnail': string;
    /**
     * 
     * @type {number}
     * @memberof LectureEntity
     */
    'order': number;
    /**
     * 
     * @type {CourseEntity}
     * @memberof LectureEntity
     */
    'course': CourseEntity;
    /**
     * 
     * @type {CourseEntity}
     * @memberof LectureEntity
     */
    'chapter': CourseEntity;
}

export const LectureEntityVisibilityEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Future: 'FUTURE',
    Pending: 'PENDING',
    Private: 'PRIVATE',
    Trash: 'TRASH'
} as const;

export type LectureEntityVisibilityEnum = typeof LectureEntityVisibilityEnum[keyof typeof LectureEntityVisibilityEnum];

/**
 * 
 * @export
 * @interface LocalSignInDto
 */
export interface LocalSignInDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInDto
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface LocalSignInResponseDto
 */
export interface LocalSignInResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignInResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignInResponseDto
     */
    'refreshToken': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof LocalSignInResponseDto
     */
    'user': UserEntity;
}
/**
 * 
 * @export
 * @interface LocalSignUpDto
 */
export interface LocalSignUpDto {
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LocalSignUpDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MatchSearchRequestDto
 */
export interface MatchSearchRequestDto {
    /**
     * 
     * @type {string}
     * @memberof MatchSearchRequestDto
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof MatchSearchRequestDto
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSearchRequestDto
     */
    'pageId': number;
}
/**
 * 
 * @export
 * @interface MatchSearchResponseDto
 */
export interface MatchSearchResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'winner': string;
    /**
     * 
     * @type {string}
     * @memberof MatchSearchResponseDto
     */
    'lastState': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchSearchResponseDto
     */
    'players': Array<string>;
}
/**
 * 
 * @export
 * @interface OkDto
 */
export interface OkDto {
    /**
     * 
     * @type {boolean}
     * @memberof OkDto
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof OkDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostEntity
 */
export interface PostEntity {
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof PostEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof PostEntity
     */
    'editors': Array<UserEntity>;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'visibility': PostEntityVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'thumbnail': string;
}

export const PostEntityVisibilityEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Future: 'FUTURE',
    Pending: 'PENDING',
    Private: 'PRIVATE',
    Trash: 'TRASH'
} as const;

export type PostEntityVisibilityEnum = typeof PostEntityVisibilityEnum[keyof typeof PostEntityVisibilityEnum];

/**
 * 
 * @export
 * @interface ProjectEntity
 */
export interface ProjectEntity {
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof ProjectEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof ProjectEntity
     */
    'editors': Array<UserEntity>;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'visibility': ProjectEntityVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectEntity
     */
    'thumbnail': string;
    /**
     * 
     * @type {Array<ProjectVersionEntity>}
     * @memberof ProjectEntity
     */
    'versions': Array<ProjectVersionEntity>;
}

export const ProjectEntityVisibilityEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Future: 'FUTURE',
    Pending: 'PENDING',
    Private: 'PRIVATE',
    Trash: 'TRASH'
} as const;

export type ProjectEntityVisibilityEnum = typeof ProjectEntityVisibilityEnum[keyof typeof ProjectEntityVisibilityEnum];

/**
 * 
 * @export
 * @interface ProjectFeedbackResponseEntity
 */
export interface ProjectFeedbackResponseEntity {
    /**
     * 
     * @type {string}
     * @memberof ProjectFeedbackResponseEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectFeedbackResponseEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectFeedbackResponseEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {ProjectVersionEntity}
     * @memberof ProjectFeedbackResponseEntity
     */
    'version': ProjectVersionEntity;
    /**
     * 
     * @type {UserEntity}
     * @memberof ProjectFeedbackResponseEntity
     */
    'user': UserEntity;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectFeedbackResponseEntity
     */
    'responses': Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestion
 */
export interface ProjectTestFeedbackQuestion {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestion
     */
    'type': ProjectTestFeedbackQuestionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestion
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestion
     */
    'isRequired': boolean;
}

export const ProjectTestFeedbackQuestionTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionTypeEnum = typeof ProjectTestFeedbackQuestionTypeEnum[keyof typeof ProjectTestFeedbackQuestionTypeEnum];

/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestionCheckbox
 */
export interface ProjectTestFeedbackQuestionCheckbox {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionCheckbox
     */
    'type': ProjectTestFeedbackQuestionCheckboxTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionCheckbox
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestionCheckbox
     */
    'isRequired': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectTestFeedbackQuestionCheckbox
     */
    'options': Array<string>;
}

export const ProjectTestFeedbackQuestionCheckboxTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionCheckboxTypeEnum = typeof ProjectTestFeedbackQuestionCheckboxTypeEnum[keyof typeof ProjectTestFeedbackQuestionCheckboxTypeEnum];

/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestionDropdown
 */
export interface ProjectTestFeedbackQuestionDropdown {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionDropdown
     */
    'type': ProjectTestFeedbackQuestionDropdownTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionDropdown
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestionDropdown
     */
    'isRequired': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectTestFeedbackQuestionDropdown
     */
    'options': Array<string>;
}

export const ProjectTestFeedbackQuestionDropdownTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionDropdownTypeEnum = typeof ProjectTestFeedbackQuestionDropdownTypeEnum[keyof typeof ProjectTestFeedbackQuestionDropdownTypeEnum];

/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestionLinearScale
 */
export interface ProjectTestFeedbackQuestionLinearScale {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'type': ProjectTestFeedbackQuestionLinearScaleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'isRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'minimum': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'maximum': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionLinearScale
     */
    'steps': number;
}

export const ProjectTestFeedbackQuestionLinearScaleTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionLinearScaleTypeEnum = typeof ProjectTestFeedbackQuestionLinearScaleTypeEnum[keyof typeof ProjectTestFeedbackQuestionLinearScaleTypeEnum];

/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestionParagraph
 */
export interface ProjectTestFeedbackQuestionParagraph {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'type': ProjectTestFeedbackQuestionParagraphTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'isRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'minimumCharacters': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'maximumCharacters': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'minimumLines': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionParagraph
     */
    'maximumLines': number;
}

export const ProjectTestFeedbackQuestionParagraphTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionParagraphTypeEnum = typeof ProjectTestFeedbackQuestionParagraphTypeEnum[keyof typeof ProjectTestFeedbackQuestionParagraphTypeEnum];

/**
 * 
 * @export
 * @interface ProjectTestFeedbackQuestionShortAnswer
 */
export interface ProjectTestFeedbackQuestionShortAnswer {
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionShortAnswer
     */
    'type': ProjectTestFeedbackQuestionShortAnswerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectTestFeedbackQuestionShortAnswer
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectTestFeedbackQuestionShortAnswer
     */
    'isRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionShortAnswer
     */
    'minimumCharacters': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectTestFeedbackQuestionShortAnswer
     */
    'maximumCharacters': number;
}

export const ProjectTestFeedbackQuestionShortAnswerTypeEnum = {
    ShortAnswer: 'SHORT_ANSWER',
    Paragraph: 'PARAGRAPH',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    LinearScale: 'LINEAR_SCALE'
} as const;

export type ProjectTestFeedbackQuestionShortAnswerTypeEnum = typeof ProjectTestFeedbackQuestionShortAnswerTypeEnum[keyof typeof ProjectTestFeedbackQuestionShortAnswerTypeEnum];

/**
 * 
 * @export
 * @interface ProjectVersionEntity
 */
export interface ProjectVersionEntity {
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'archive_url': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'notes_url': string;
    /**
     * 
     * @type {Array<ProjectVersionEntityFeedbackFormInner>}
     * @memberof ProjectVersionEntity
     */
    'feedback_form': Array<ProjectVersionEntityFeedbackFormInner>;
    /**
     * 
     * @type {string}
     * @memberof ProjectVersionEntity
     */
    'feedback_deadline': string;
    /**
     * 
     * @type {ProjectEntity}
     * @memberof ProjectVersionEntity
     */
    'project': ProjectEntity;
    /**
     * 
     * @type {Array<ProjectFeedbackResponseEntity>}
     * @memberof ProjectVersionEntity
     */
    'responses': Array<ProjectFeedbackResponseEntity>;
}
/**
 * @type ProjectVersionEntityFeedbackFormInner
 * @export
 */
export type ProjectVersionEntityFeedbackFormInner = ProjectTestFeedbackQuestion | ProjectTestFeedbackQuestionCheckbox | ProjectTestFeedbackQuestionDropdown | ProjectTestFeedbackQuestionLinearScale | ProjectTestFeedbackQuestionParagraph | ProjectTestFeedbackQuestionShortAnswer;

/**
 * 
 * @export
 * @interface TransferOwnershipRequestDto
 */
export interface TransferOwnershipRequestDto {
    /**
     * 
     * @type {string}
     * @memberof TransferOwnershipRequestDto
     */
    'id': string;
    /**
     * 
     * @type {IdDto}
     * @memberof TransferOwnershipRequestDto
     */
    'newUser': IdDto;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserEntity
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordHash': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordSalt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'facebookId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'googleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'githubId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'appleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'linkedinId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'twitterId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'walletAddress': string;
    /**
     * 
     * @type {UserProfileEntity}
     * @memberof UserEntity
     */
    'profile': UserProfileEntity;
    /**
     * 
     * @type {Array<CompetitionSubmissionEntity>}
     * @memberof UserEntity
     */
    'competitionSubmissions': Array<CompetitionSubmissionEntity>;
    /**
     * 
     * @type {number}
     * @memberof UserEntity
     */
    'elo': number;
    /**
     * 
     * @type {Array<PostEntity>}
     * @memberof UserEntity
     */
    'posts': Array<PostEntity>;
    /**
     * 
     * @type {Array<CourseEntity>}
     * @memberof UserEntity
     */
    'courses': Array<CourseEntity>;
}
/**
 * 
 * @export
 * @interface UserProfileEntity
 */
export interface UserProfileEntity {
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserEntity}
     * @memberof UserProfileEntity
     */
    'user': UserEntity;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'givenName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'familyName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileEntity
     */
    'picture': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EthereumSigninChallengeRequestDto} ethereumSigninChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetWeb3SignInChallenge: async (ethereumSigninChallengeRequestDto: EthereumSigninChallengeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ethereumSigninChallengeRequestDto' is not null or undefined
            assertParamExists('authControllerGetWeb3SignInChallenge', 'ethereumSigninChallengeRequestDto', ethereumSigninChallengeRequestDto)
            const localVarPath = `/auth/web3/sign-in/challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ethereumSigninChallengeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLocalSignWithEmailOrUsername: async (localSignInDto: LocalSignInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localSignInDto' is not null or undefined
            assertParamExists('authControllerLocalSignWithEmailOrUsername', 'localSignInDto', localSignInDto)
            const localVarPath = `/auth/local/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localSignInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EmailDto} emailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMagicLink: async (emailDto: EmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailDto' is not null or undefined
            assertParamExists('authControllerMagicLink', 'emailDto', emailDto)
            const localVarPath = `/auth/magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithGoogle: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerSignInWithGoogle', 'token', token)
            const localVarPath = `/auth/google/callback/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailUsernamePassword: async (localSignUpDto: LocalSignUpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localSignUpDto' is not null or undefined
            assertParamExists('authControllerSignUpWithEmailUsernamePassword', 'localSignUpDto', localSignUpDto)
            const localVarPath = `/auth/local/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localSignUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserExists: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authControllerUserExists', 'user', user)
            const localVarPath = `/auth/userExists/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EthereumSigninValidateRequestDto} ethereumSigninValidateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerValidateWeb3SignInChallenge: async (ethereumSigninValidateRequestDto: EthereumSigninValidateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ethereumSigninValidateRequestDto' is not null or undefined
            assertParamExists('authControllerValidateWeb3SignInChallenge', 'ethereumSigninValidateRequestDto', ethereumSigninValidateRequestDto)
            const localVarPath = `/auth/web3/sign-in/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ethereumSigninValidateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EthereumSigninChallengeRequestDto} ethereumSigninChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto: EthereumSigninChallengeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumSigninChallengeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetWeb3SignInChallenge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLocalSignWithEmailOrUsername(localSignInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLocalSignWithEmailOrUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EmailDto} emailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMagicLink(emailDto: EmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMagicLink(emailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerMagicLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalSignInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignInWithGoogle(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalSignInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignInWithGoogle(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignInWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalSignInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignUpWithEmailUsernamePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUserExists(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUserExists(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerUserExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EthereumSigninValidateRequestDto} ethereumSigninValidateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto: EthereumSigninValidateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalSignInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerValidateWeb3SignInChallenge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCurrentUser(options?: any): AxiosPromise<UserEntity> {
            return localVarFp.authControllerGetCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EthereumSigninChallengeRequestDto} ethereumSigninChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto: EthereumSigninChallengeRequestDto, options?: any): AxiosPromise<EthereumSigninChallengeResponseDto> {
            return localVarFp.authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LocalSignInDto} localSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerLocalSignWithEmailOrUsername(localSignInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EmailDto} emailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMagicLink(emailDto: EmailDto, options?: any): AxiosPromise<OkDto> {
            return localVarFp.authControllerMagicLink(emailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(options?: any): AxiosPromise<LocalSignInResponseDto> {
            return localVarFp.authControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithGoogle(token: string, options?: any): AxiosPromise<LocalSignInResponseDto> {
            return localVarFp.authControllerSignInWithGoogle(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LocalSignUpDto} localSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: any): AxiosPromise<LocalSignInResponseDto> {
            return localVarFp.authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUserExists(user: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerUserExists(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EthereumSigninValidateRequestDto} ethereumSigninValidateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto: EthereumSigninValidateRequestDto, options?: any): AxiosPromise<LocalSignInResponseDto> {
            return localVarFp.authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EthereumSigninChallengeRequestDto} ethereumSigninChallengeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto: EthereumSigninChallengeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetWeb3SignInChallenge(ethereumSigninChallengeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LocalSignInDto} localSignInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLocalSignWithEmailOrUsername(localSignInDto: LocalSignInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLocalSignWithEmailOrUsername(localSignInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EmailDto} emailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerMagicLink(emailDto: EmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerMagicLink(emailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignInWithGoogle(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignInWithGoogle(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LocalSignUpDto} localSignUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUpWithEmailUsernamePassword(localSignUpDto: LocalSignUpDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUpWithEmailUsernamePassword(localSignUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUserExists(user: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerUserExists(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EthereumSigninValidateRequestDto} ethereumSigninValidateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto: EthereumSigninValidateRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerValidateWeb3SignInChallenge(ethereumSigninValidateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompetitionsApi - axios parameter creator
 * @export
 */
export const CompetitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerFindChessMatchResult: async (matchSearchRequestDto: MatchSearchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchSearchRequestDto' is not null or undefined
            assertParamExists('competitionControllerFindChessMatchResult', 'matchSearchRequestDto', matchSearchRequestDto)
            const localVarPath = `/Competitions/Chess/FindMatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchSearchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessLeaderboard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/Leaderboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessMatchResult: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('competitionControllerGetChessMatchResult', 'id', id)
            const localVarPath = `/Competitions/Chess/Match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetLatestChessCompetitionReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/LatestCompetitionReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerListChessAgents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/ListAgents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRequestChessMove: async (chessMoveRequestDto: ChessMoveRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chessMoveRequestDto' is not null or undefined
            assertParamExists('competitionControllerRequestChessMove', 'chessMoveRequestDto', chessMoveRequestDto)
            const localVarPath = `/Competitions/Chess/Move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chessMoveRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunChessMatch: async (chessMatchRequestDto: ChessMatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chessMatchRequestDto' is not null or undefined
            assertParamExists('competitionControllerRunChessMatch', 'chessMatchRequestDto', chessMatchRequestDto)
            const localVarPath = `/Competitions/Chess/RunMatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chessMatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunCompetition: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Competitions/Chess/RunCompetition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerSubmitChessAgent: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('competitionControllerSubmitChessAgent', 'file', file)
            const localVarPath = `/Competitions/Chess/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompetitionsApi - functional programming interface
 * @export
 */
export const CompetitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompetitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchSearchResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerFindChessMatchResult(matchSearchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerFindChessMatchResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetChessLeaderboard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChessLeaderboardResponseEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetChessLeaderboard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetChessLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetChessMatchResult(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChessMatchResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetChessMatchResult(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetChessMatchResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerGetLatestChessCompetitionReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompetitionRunSubmissionReportEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerGetLatestChessCompetitionReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerGetLatestChessCompetitionReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerListChessAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerListChessAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerListChessAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRequestChessMove(chessMoveRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRequestChessMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChessMatchResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRunChessMatch(chessMatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRunChessMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerRunCompetition(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerRunCompetition(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerRunCompetition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async competitionControllerSubmitChessAgent(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.competitionControllerSubmitChessAgent(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitionsApi.competitionControllerSubmitChessAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompetitionsApi - factory interface
 * @export
 */
export const CompetitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompetitionsApiFp(configuration)
    return {
        /**
         * 
         * @param {MatchSearchRequestDto} matchSearchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: any): AxiosPromise<Array<MatchSearchResponseDto>> {
            return localVarFp.competitionControllerFindChessMatchResult(matchSearchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessLeaderboard(options?: any): AxiosPromise<Array<ChessLeaderboardResponseEntryDto>> {
            return localVarFp.competitionControllerGetChessLeaderboard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetChessMatchResult(id: string, options?: any): AxiosPromise<ChessMatchResultDto> {
            return localVarFp.competitionControllerGetChessMatchResult(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerGetLatestChessCompetitionReport(options?: any): AxiosPromise<Array<CompetitionRunSubmissionReportEntity>> {
            return localVarFp.competitionControllerGetLatestChessCompetitionReport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerListChessAgents(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.competitionControllerListChessAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChessMoveRequestDto} chessMoveRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.competitionControllerRequestChessMove(chessMoveRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChessMatchRequestDto} chessMatchRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: any): AxiosPromise<ChessMatchResultDto> {
            return localVarFp.competitionControllerRunChessMatch(chessMatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerRunCompetition(options?: any): AxiosPromise<void> {
            return localVarFp.competitionControllerRunCompetition(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competitionControllerSubmitChessAgent(file: File, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.competitionControllerSubmitChessAgent(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompetitionsApi - object-oriented interface
 * @export
 * @class CompetitionsApi
 * @extends {BaseAPI}
 */
export class CompetitionsApi extends BaseAPI {
    /**
     * 
     * @param {MatchSearchRequestDto} matchSearchRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerFindChessMatchResult(matchSearchRequestDto: MatchSearchRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerFindChessMatchResult(matchSearchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetChessLeaderboard(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetChessLeaderboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetChessMatchResult(id: string, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetChessMatchResult(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerGetLatestChessCompetitionReport(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerGetLatestChessCompetitionReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerListChessAgents(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerListChessAgents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChessMoveRequestDto} chessMoveRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRequestChessMove(chessMoveRequestDto: ChessMoveRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRequestChessMove(chessMoveRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChessMatchRequestDto} chessMatchRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRunChessMatch(chessMatchRequestDto: ChessMatchRequestDto, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRunChessMatch(chessMatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerRunCompetition(options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerRunCompetition(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetitionsApi
     */
    public competitionControllerSubmitChessAgent(file: File, options?: RawAxiosRequestConfig) {
        return CompetitionsApiFp(this.configuration).competitionControllerSubmitChessAgent(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentControllerCreateEmptyCourse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/course/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentControllerCreateEmptyCourse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentControllerCreateEmptyCourse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentControllerCreateEmptyCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentControllerCreateEmptyCourse(options?: any): AxiosPromise<CourseEntity> {
            return localVarFp.contentControllerCreateEmptyCourse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentControllerCreateEmptyCourse(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentControllerCreateEmptyCourse(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a single ProjectEntity
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneBaseProjectControllerProjectEntity: async (projectEntity: ProjectEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectEntity' is not null or undefined
            assertParamExists('createOneBaseProjectControllerProjectEntity', 'projectEntity', projectEntity)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single ProjectEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOneBaseProjectControllerProjectEntity: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOneBaseProjectControllerProjectEntity', 'id', id)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve multiple ProjectEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyBaseProjectControllerProjectEntity: async (fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (or) {
                localVarQueryParameter['or'] = or;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (join) {
                localVarQueryParameter['join'] = join;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single ProjectEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBaseProjectControllerProjectEntity: async (id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneBaseProjectControllerProjectEntity', 'id', id)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (join) {
                localVarQueryParameter['join'] = join;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerAddEditor: async (editorRequestDto: EditorRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editorRequestDto' is not null or undefined
            assertParamExists('projectControllerAddEditor', 'editorRequestDto', editorRequestDto)
            const localVarPath = `/project/add-editor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editorRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemoveEditor: async (editorRequestDto: EditorRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editorRequestDto' is not null or undefined
            assertParamExists('projectControllerRemoveEditor', 'editorRequestDto', editorRequestDto)
            const localVarPath = `/project/remove-editor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editorRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransferOwnershipRequestDto} transferOwnershipRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerSwitchOwner: async (transferOwnershipRequestDto: TransferOwnershipRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferOwnershipRequestDto' is not null or undefined
            assertParamExists('projectControllerSwitchOwner', 'transferOwnershipRequestDto', transferOwnershipRequestDto)
            const localVarPath = `/project/transfer-ownership`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single ProjectEntity
         * @param {string} id 
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOneBaseProjectControllerProjectEntity: async (id: string, projectEntity: ProjectEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOneBaseProjectControllerProjectEntity', 'id', id)
            // verify required parameter 'projectEntity' is not null or undefined
            assertParamExists('updateOneBaseProjectControllerProjectEntity', 'projectEntity', projectEntity)
            const localVarPath = `/project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a single ProjectEntity
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOneBaseProjectControllerProjectEntity(projectEntity: ProjectEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOneBaseProjectControllerProjectEntity(projectEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.createOneBaseProjectControllerProjectEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single ProjectEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOneBaseProjectControllerProjectEntity(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOneBaseProjectControllerProjectEntity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.deleteOneBaseProjectControllerProjectEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve multiple ProjectEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyBaseProjectControllerProjectEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManyBaseProjectControllerProjectEntity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyBaseProjectControllerProjectEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.getManyBaseProjectControllerProjectEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a single ProjectEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneBaseProjectControllerProjectEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneBaseProjectControllerProjectEntity(id, fields, join, cache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.getOneBaseProjectControllerProjectEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerAddEditor(editorRequestDto: EditorRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerAddEditor(editorRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerAddEditor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerRemoveEditor(editorRequestDto: EditorRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerRemoveEditor(editorRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerRemoveEditor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TransferOwnershipRequestDto} transferOwnershipRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerSwitchOwner(transferOwnershipRequestDto: TransferOwnershipRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerSwitchOwner(transferOwnershipRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.projectControllerSwitchOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a single ProjectEntity
         * @param {string} id 
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOneBaseProjectControllerProjectEntity(id: string, projectEntity: ProjectEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOneBaseProjectControllerProjectEntity(id, projectEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.updateOneBaseProjectControllerProjectEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a single ProjectEntity
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneBaseProjectControllerProjectEntity(projectEntity: ProjectEntity, options?: any): AxiosPromise<ProjectEntity> {
            return localVarFp.createOneBaseProjectControllerProjectEntity(projectEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single ProjectEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOneBaseProjectControllerProjectEntity(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOneBaseProjectControllerProjectEntity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve multiple ProjectEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyBaseProjectControllerProjectEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: any): AxiosPromise<GetManyBaseProjectControllerProjectEntity200Response> {
            return localVarFp.getManyBaseProjectControllerProjectEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a single ProjectEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBaseProjectControllerProjectEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: any): AxiosPromise<ProjectEntity> {
            return localVarFp.getOneBaseProjectControllerProjectEntity(id, fields, join, cache, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerAddEditor(editorRequestDto: EditorRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectControllerAddEditor(editorRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditorRequestDto} editorRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemoveEditor(editorRequestDto: EditorRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectControllerRemoveEditor(editorRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransferOwnershipRequestDto} transferOwnershipRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerSwitchOwner(transferOwnershipRequestDto: TransferOwnershipRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectControllerSwitchOwner(transferOwnershipRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a single ProjectEntity
         * @param {string} id 
         * @param {ProjectEntity} projectEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOneBaseProjectControllerProjectEntity(id: string, projectEntity: ProjectEntity, options?: any): AxiosPromise<ProjectEntity> {
            return localVarFp.updateOneBaseProjectControllerProjectEntity(id, projectEntity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Create a single ProjectEntity
     * @param {ProjectEntity} projectEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createOneBaseProjectControllerProjectEntity(projectEntity: ProjectEntity, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).createOneBaseProjectControllerProjectEntity(projectEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single ProjectEntity
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteOneBaseProjectControllerProjectEntity(id: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).deleteOneBaseProjectControllerProjectEntity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve multiple ProjectEntities
     * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getManyBaseProjectControllerProjectEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getManyBaseProjectControllerProjectEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a single ProjectEntity
     * @param {string} id 
     * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getOneBaseProjectControllerProjectEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getOneBaseProjectControllerProjectEntity(id, fields, join, cache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditorRequestDto} editorRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerAddEditor(editorRequestDto: EditorRequestDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerAddEditor(editorRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditorRequestDto} editorRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerRemoveEditor(editorRequestDto: EditorRequestDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerRemoveEditor(editorRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransferOwnershipRequestDto} transferOwnershipRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectControllerSwitchOwner(transferOwnershipRequestDto: TransferOwnershipRequestDto, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectControllerSwitchOwner(transferOwnershipRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a single ProjectEntity
     * @param {string} id 
     * @param {ProjectEntity} projectEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateOneBaseProjectControllerProjectEntity(id: string, projectEntity: ProjectEntity, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).updateOneBaseProjectControllerProjectEntity(id, projectEntity, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectVersionApi - axios parameter creator
 * @export
 */
export const ProjectVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a single ProjectVersionEntity
         * @param {ProjectVersionEntity} projectVersionEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneBaseProjectVersionControllerProjectVersionEntity: async (projectVersionEntity: ProjectVersionEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectVersionEntity' is not null or undefined
            assertParamExists('createOneBaseProjectVersionControllerProjectVersionEntity', 'projectVersionEntity', projectVersionEntity)
            const localVarPath = `/project-version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectVersionEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single ProjectVersionEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOneBaseProjectVersionControllerProjectVersionEntity: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOneBaseProjectVersionControllerProjectVersionEntity', 'id', id)
            const localVarPath = `/project-version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve multiple ProjectVersionEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyBaseProjectVersionControllerProjectVersionEntity: async (fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project-version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (or) {
                localVarQueryParameter['or'] = or;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (join) {
                localVarQueryParameter['join'] = join;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single ProjectVersionEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBaseProjectVersionControllerProjectVersionEntity: async (id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneBaseProjectVersionControllerProjectVersionEntity', 'id', id)
            const localVarPath = `/project-version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (join) {
                localVarQueryParameter['join'] = join;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectVersionApi - functional programming interface
 * @export
 */
export const ProjectVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a single ProjectVersionEntity
         * @param {ProjectVersionEntity} projectVersionEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity: ProjectVersionEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectVersionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectVersionApi.createOneBaseProjectVersionControllerProjectVersionEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single ProjectVersionEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectVersionApi.deleteOneBaseProjectVersionControllerProjectVersionEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve multiple ProjectVersionEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyBaseProjectVersionControllerProjectVersionEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManyBaseProjectVersionControllerProjectVersionEntity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyBaseProjectVersionControllerProjectVersionEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectVersionApi.getManyBaseProjectVersionControllerProjectVersionEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a single ProjectVersionEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectVersionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneBaseProjectVersionControllerProjectVersionEntity(id, fields, join, cache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectVersionApi.getOneBaseProjectVersionControllerProjectVersionEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectVersionApi - factory interface
 * @export
 */
export const ProjectVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a single ProjectVersionEntity
         * @param {ProjectVersionEntity} projectVersionEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity: ProjectVersionEntity, options?: any): AxiosPromise<ProjectVersionEntity> {
            return localVarFp.createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single ProjectVersionEntity
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve multiple ProjectVersionEntities
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyBaseProjectVersionControllerProjectVersionEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: any): AxiosPromise<GetManyBaseProjectVersionControllerProjectVersionEntity200Response> {
            return localVarFp.getManyBaseProjectVersionControllerProjectVersionEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a single ProjectVersionEntity
         * @param {string} id 
         * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: any): AxiosPromise<ProjectVersionEntity> {
            return localVarFp.getOneBaseProjectVersionControllerProjectVersionEntity(id, fields, join, cache, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectVersionApi - object-oriented interface
 * @export
 * @class ProjectVersionApi
 * @extends {BaseAPI}
 */
export class ProjectVersionApi extends BaseAPI {
    /**
     * 
     * @summary Create a single ProjectVersionEntity
     * @param {ProjectVersionEntity} projectVersionEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectVersionApi
     */
    public createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity: ProjectVersionEntity, options?: RawAxiosRequestConfig) {
        return ProjectVersionApiFp(this.configuration).createOneBaseProjectVersionControllerProjectVersionEntity(projectVersionEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single ProjectVersionEntity
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectVersionApi
     */
    public deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RawAxiosRequestConfig) {
        return ProjectVersionApiFp(this.configuration).deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve multiple ProjectVersionEntities
     * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {string} [s] Adds search condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#search\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [filter] Adds filter condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#filter\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [or] Adds OR condition. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#or\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [sort] Adds sort by field. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#sort\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [limit] Limit amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#limit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [offset] Offset amount of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#offset\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [page] Page portion of resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#page\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectVersionApi
     */
    public getManyBaseProjectVersionControllerProjectVersionEntity(fields?: Array<string>, s?: string, filter?: Array<string>, or?: Array<string>, sort?: Array<string>, join?: Array<string>, limit?: number, offset?: number, page?: number, cache?: number, options?: RawAxiosRequestConfig) {
        return ProjectVersionApiFp(this.configuration).getManyBaseProjectVersionControllerProjectVersionEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a single ProjectVersionEntity
     * @param {string} id 
     * @param {Array<string>} [fields] Selects resource fields. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#select\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {Array<string>} [join] Adds relational resources. &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#join\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {number} [cache] Reset cache (if was enabled). &lt;a href&#x3D;\&quot;https://github.com/nestjsx/crud/wiki/Requests#cache\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Docs&lt;/a&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectVersionApi
     */
    public getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields?: Array<string>, join?: Array<string>, cache?: number, options?: RawAxiosRequestConfig) {
        return ProjectVersionApiFp(this.configuration).getOneBaseProjectVersionControllerProjectVersionEntity(id, fields, join, cache, options).then((request) => request(this.axios, this.basePath));
    }
}



