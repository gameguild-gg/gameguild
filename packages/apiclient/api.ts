/* eslint-disable */
// tslint:disable
/**
 * gameguild.gg
 * 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

export namespace AuthApi {
	export type AuthControllerGetCurrentUserResponse =
		| AuthControllerGetCurrentUser400Response
		| AuthControllerGetCurrentUser401Response
		| AuthControllerGetCurrentUser403Response
		| AuthControllerGetCurrentUser404Response
		| AuthControllerGetCurrentUser409Response
		| AuthControllerGetCurrentUser422Response
		| AuthControllerGetCurrentUser500Response
		| AuthControllerGetCurrentUserDefaultResponse
	
	export interface AuthControllerGetCurrentUser400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUserDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserEntity
		headers?: undefined
	}
	
	export type AuthControllerGetWeb3SignInChallengeResponse =
		| AuthControllerGetWeb3SignInChallenge400Response
		| AuthControllerGetWeb3SignInChallenge422Response
		| AuthControllerGetWeb3SignInChallenge500Response
		| AuthControllerGetWeb3SignInChallengeDefaultResponse
	
	export interface AuthControllerGetWeb3SignInChallenge400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetWeb3SignInChallenge422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetWeb3SignInChallenge500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetWeb3SignInChallengeDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.EthereumSigninChallengeResponseDto
		headers?: undefined
	}
	
	export type AuthControllerMagicLinkResponse =
		| AuthControllerMagicLink400Response
		| AuthControllerMagicLink422Response
		| AuthControllerMagicLink500Response
		| AuthControllerMagicLinkDefaultResponse
	
	export interface AuthControllerMagicLink400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerMagicLink422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerMagicLink500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerMagicLinkDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.OkDto
		headers?: undefined
	}
	
	export type AuthControllerRefreshTokenResponse =
		| AuthControllerRefreshToken400Response
		| AuthControllerRefreshToken401Response
		| AuthControllerRefreshToken403Response
		| AuthControllerRefreshToken404Response
		| AuthControllerRefreshToken409Response
		| AuthControllerRefreshToken422Response
		| AuthControllerRefreshToken500Response
		| AuthControllerRefreshTokenDefaultResponse
	
	export interface AuthControllerRefreshToken400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshTokenDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerSignInWithGoogleResponse =
		| AuthControllerSignInWithGoogle400Response
		| AuthControllerSignInWithGoogle422Response
		| AuthControllerSignInWithGoogle500Response
		| AuthControllerSignInWithGoogleDefaultResponse
	
	export interface AuthControllerSignInWithGoogle400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignInWithGoogle422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignInWithGoogle500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignInWithGoogleDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerSignUpWithEmailUsernamePasswordResponse =
		| AuthControllerSignUpWithEmailUsernamePassword400Response
		| AuthControllerSignUpWithEmailUsernamePassword422Response
		| AuthControllerSignUpWithEmailUsernamePassword500Response
		| AuthControllerSignUpWithEmailUsernamePasswordDefaultResponse
	
	export interface AuthControllerSignUpWithEmailUsernamePassword400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignUpWithEmailUsernamePassword422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignUpWithEmailUsernamePassword500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerSignUpWithEmailUsernamePasswordDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerUserExistsResponse =
		| AuthControllerUserExists400Response
		| AuthControllerUserExists422Response
		| AuthControllerUserExists500Response
		| AuthControllerUserExistsDefaultResponse
	
	export interface AuthControllerUserExists400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerUserExists422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerUserExists500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerUserExistsDefaultResponse {
		status: number
		contentType: 'application/json'
		body: boolean
		headers?: undefined
	}
	
	export type AuthControllerValidateWeb3SignInChallengeResponse =
		| AuthControllerValidateWeb3SignInChallenge400Response
		| AuthControllerValidateWeb3SignInChallenge422Response
		| AuthControllerValidateWeb3SignInChallenge500Response
		| AuthControllerValidateWeb3SignInChallengeDefaultResponse
	
	export interface AuthControllerValidateWeb3SignInChallenge400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerValidateWeb3SignInChallenge422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerValidateWeb3SignInChallenge500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerValidateWeb3SignInChallengeDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
}

/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/auth/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerGetWeb3SignInChallenge.');
			}

			let localVarPath = `/auth/web3/sign-in/challenge`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerMagicLink.');
			}

			let localVarPath = `/auth/magic-link`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/auth/refresh-token`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'token' is not null or undefined
			if (token === null || token === undefined) {
				throw new RequiredError('token', 'Required parameter token was null or undefined when calling authControllerSignInWithGoogle.');
			}

			let localVarPath = `/auth/google/callback/{token}`
				.replace('{token}', encodeURIComponent(String(token)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerSignUpWithEmailUsernamePassword.');
			}

			let localVarPath = `/auth/local/sign-up`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'user' is not null or undefined
			if (user === null || user === undefined) {
				throw new RequiredError('user', 'Required parameter user was null or undefined when calling authControllerUserExists.');
			}

			let localVarPath = `/auth/userExists/{user}`
				.replace('{user}', encodeURIComponent(String(user)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerValidateWeb3SignInChallenge.');
			}

			let localVarPath = `/auth/web3/sign-in/validate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerGetCurrentUserResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetCurrentUser(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerGetWeb3SignInChallengeResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetWeb3SignInChallenge(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.EthereumSigninChallengeResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerMagicLinkResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerMagicLink(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.OkDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerRefreshTokenResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerRefreshToken(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerSignInWithGoogleResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignInWithGoogle(token, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerSignUpWithEmailUsernamePasswordResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignUpWithEmailUsernamePassword(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerUserExistsResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerUserExists(user, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as boolean,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerValidateWeb3SignInChallengeResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerValidateWeb3SignInChallenge(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory: FactoryFunction<AuthApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new AuthApi(configuration, basePath, fetch);
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerGetCurrentUser(options?: RequestInit): Promise<AuthApi.AuthControllerGetCurrentUserResponse>

	/**
	 * @param {Api.EthereumSigninChallengeRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit): Promise<AuthApi.AuthControllerGetWeb3SignInChallengeResponse>

	/**
	 * @param {Api.EmailDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerMagicLink(request: Api.EmailDto, options?: RequestInit): Promise<AuthApi.AuthControllerMagicLinkResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerRefreshToken(options?: RequestInit): Promise<AuthApi.AuthControllerRefreshTokenResponse>

	/**
	 * @param {string} token
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerSignInWithGoogle(token: string, options?: RequestInit): Promise<AuthApi.AuthControllerSignInWithGoogleResponse>

	/**
	 * @param {Api.LocalSignUpDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit): Promise<AuthApi.AuthControllerSignUpWithEmailUsernamePasswordResponse>

	/**
	 * @param {string} user
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerUserExists(user: string, options?: RequestInit): Promise<AuthApi.AuthControllerUserExistsResponse>

	/**
	 * @param {Api.EthereumSigninValidateRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit): Promise<AuthApi.AuthControllerValidateWeb3SignInChallengeResponse>

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetCurrentUser(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetCurrentUser(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninChallengeRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EmailDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerMagicLink(request: Api.EmailDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerMagicLink(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerRefreshToken(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerRefreshToken(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} token
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignInWithGoogle(token: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignInWithGoogle(token, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.LocalSignUpDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignUpWithEmailUsernamePassword(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} user
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerUserExists(user: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerUserExists(user, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninValidateRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerValidateWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

}
export namespace CertificatesApi {
	export type CertificateControllerCreateTemplateResponse =
		| CertificateControllerCreateTemplate201Response
	
	export interface CertificateControllerCreateTemplate201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export interface CertificateControllerGetTemplatesParameters {
		programId: string
		productId: string
	}
	
	export type CertificateControllerGetTemplatesResponse =
		| CertificateControllerGetTemplates200Response
	
	export interface CertificateControllerGetTemplates200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type CertificateControllerGetUserCertificatesResponse =
		| CertificateControllerGetUserCertificates200Response
	
	export interface CertificateControllerGetUserCertificates200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type CertificateControllerIssueCertificateResponse =
		| CertificateControllerIssueCertificate201Response
	
	export interface CertificateControllerIssueCertificate201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export type CertificateControllerVerifyCertificateResponse =
		| CertificateControllerVerifyCertificate200Response
	
	export interface CertificateControllerVerifyCertificate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.CertificateVerificationResult
		headers?: undefined
	}
	
}

/**
 * CertificatesApi - fetch parameter creator
 * @export
 */
export const CertificatesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a new certificate template
		 * @param {Api.CreateCertificateTemplateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerCreateTemplate(request: Api.CreateCertificateTemplateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling certificateControllerCreateTemplate.');
			}

			let localVarPath = `/certificates/templates`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get all certificate templates
		 * @param {string} programId
		 * @param {string} productId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerGetTemplates(__params: CertificatesApi.CertificateControllerGetTemplatesParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'programId' is not null or undefined
			if (__params.programId === null || __params.programId === undefined) {
				throw new RequiredError('programId', 'Required parameter programId was null or undefined when calling certificateControllerGetTemplates.');
			}
			// verify required parameter 'productId' is not null or undefined
			if (__params.productId === null || __params.productId === undefined) {
				throw new RequiredError('productId', 'Required parameter productId was null or undefined when calling certificateControllerGetTemplates.');
			}

			let localVarPath = `/certificates/templates`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.programId !== undefined) {
				localVarQueryParameter.append('programId', String(__params.programId));
			}

			if (__params.productId !== undefined) {
				localVarQueryParameter.append('productId', String(__params.productId));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get certificates for a specific user
		 * @param {string} userId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerGetUserCertificates(userId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'userId' is not null or undefined
			if (userId === null || userId === undefined) {
				throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling certificateControllerGetUserCertificates.');
			}

			let localVarPath = `/certificates/user/{userId}`
				.replace('{userId}', encodeURIComponent(String(userId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Issue a certificate to a user
		 * @param {Api.IssueCertificateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerIssueCertificate(request: Api.IssueCertificateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling certificateControllerIssueCertificate.');
			}

			let localVarPath = `/certificates/issue`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Verify a certificate by ID
		 * @param {string} certificateId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerVerifyCertificate(certificateId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'certificateId' is not null or undefined
			if (certificateId === null || certificateId === undefined) {
				throw new RequiredError('certificateId', 'Required parameter certificateId was null or undefined when calling certificateControllerVerifyCertificate.');
			}

			let localVarPath = `/certificates/verify/{certificateId}`
				.replace('{certificateId}', encodeURIComponent(String(certificateId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * CertificatesApi - functional programming interface
 * @export
 */
export const CertificatesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a new certificate template
		 * @param {Api.CreateCertificateTemplateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerCreateTemplate(request: Api.CreateCertificateTemplateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CertificatesApi.CertificateControllerCreateTemplateResponse> {
			const localVarFetchArgs = CertificatesApiFetchParamCreator(configuration).certificateControllerCreateTemplate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get all certificate templates
		 * @param {string} programId
		 * @param {string} productId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerGetTemplates(__params: CertificatesApi.CertificateControllerGetTemplatesParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CertificatesApi.CertificateControllerGetTemplatesResponse> {
			const localVarFetchArgs = CertificatesApiFetchParamCreator(configuration).certificateControllerGetTemplates(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get certificates for a specific user
		 * @param {string} userId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerGetUserCertificates(userId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CertificatesApi.CertificateControllerGetUserCertificatesResponse> {
			const localVarFetchArgs = CertificatesApiFetchParamCreator(configuration).certificateControllerGetUserCertificates(userId, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Issue a certificate to a user
		 * @param {Api.IssueCertificateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerIssueCertificate(request: Api.IssueCertificateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CertificatesApi.CertificateControllerIssueCertificateResponse> {
			const localVarFetchArgs = CertificatesApiFetchParamCreator(configuration).certificateControllerIssueCertificate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Verify a certificate by ID
		 * @param {string} certificateId
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		certificateControllerVerifyCertificate(certificateId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CertificatesApi.CertificateControllerVerifyCertificateResponse> {
			const localVarFetchArgs = CertificatesApiFetchParamCreator(configuration).certificateControllerVerifyCertificate(certificateId, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.CertificateVerificationResult,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * CertificatesApi - factory interface
 * @export
 */
export const CertificatesApiFactory: FactoryFunction<CertificatesApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new CertificatesApi(configuration, basePath, fetch);
};

/**
 * CertificatesApi - interface
 * @export
 * @interface CertificatesApi
 */
export interface CertificatesApiInterface {
	/**
	 * @summary Create a new certificate template
	 * @param {Api.CreateCertificateTemplateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	certificateControllerCreateTemplate(request: Api.CreateCertificateTemplateDto, options?: RequestInit): Promise<CertificatesApi.CertificateControllerCreateTemplateResponse>

	/**
	 * @summary Get all certificate templates
	 * @param {string} programId
	 * @param {string} productId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	certificateControllerGetTemplates(__params: CertificatesApi.CertificateControllerGetTemplatesParameters, options?: RequestInit): Promise<CertificatesApi.CertificateControllerGetTemplatesResponse>

	/**
	 * @summary Get certificates for a specific user
	 * @param {string} userId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	certificateControllerGetUserCertificates(userId: string, options?: RequestInit): Promise<CertificatesApi.CertificateControllerGetUserCertificatesResponse>

	/**
	 * @summary Issue a certificate to a user
	 * @param {Api.IssueCertificateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	certificateControllerIssueCertificate(request: Api.IssueCertificateDto, options?: RequestInit): Promise<CertificatesApi.CertificateControllerIssueCertificateResponse>

	/**
	 * @summary Verify a certificate by ID
	 * @param {string} certificateId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	certificateControllerVerifyCertificate(certificateId: string, options?: RequestInit): Promise<CertificatesApi.CertificateControllerVerifyCertificateResponse>

}

/**
 * CertificatesApi - object-oriented interface
 * @export
 * @class CertificatesApi
 * @extends {BaseAPI}
 */
export class CertificatesApi extends BaseAPI implements CertificatesApiInterface {
	/**
	 * @summary Create a new certificate template
	 * @param {Api.CreateCertificateTemplateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public certificateControllerCreateTemplate(request: Api.CreateCertificateTemplateDto, options?: RequestInit) {
		return CertificatesApiFp(this.configuration).certificateControllerCreateTemplate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get all certificate templates
	 * @param {string} programId
	 * @param {string} productId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public certificateControllerGetTemplates(__params: CertificatesApi.CertificateControllerGetTemplatesParameters, options?: RequestInit) {
		return CertificatesApiFp(this.configuration).certificateControllerGetTemplates(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get certificates for a specific user
	 * @param {string} userId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public certificateControllerGetUserCertificates(userId: string, options?: RequestInit) {
		return CertificatesApiFp(this.configuration).certificateControllerGetUserCertificates(userId, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Issue a certificate to a user
	 * @param {Api.IssueCertificateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public certificateControllerIssueCertificate(request: Api.IssueCertificateDto, options?: RequestInit) {
		return CertificatesApiFp(this.configuration).certificateControllerIssueCertificate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Verify a certificate by ID
	 * @param {string} certificateId
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public certificateControllerVerifyCertificate(certificateId: string, options?: RequestInit) {
		return CertificatesApiFp(this.configuration).certificateControllerVerifyCertificate(certificateId, options)(this.fetch, this.basePath);
	}

}
export namespace CompetitionsApi {
	export type CompetitionControllerFindChessMatchResultResponse =
		| CompetitionControllerFindChessMatchResult400Response
		| CompetitionControllerFindChessMatchResult401Response
		| CompetitionControllerFindChessMatchResult403Response
		| CompetitionControllerFindChessMatchResult404Response
		| CompetitionControllerFindChessMatchResult409Response
		| CompetitionControllerFindChessMatchResult422Response
		| CompetitionControllerFindChessMatchResult500Response
		| CompetitionControllerFindChessMatchResultDefaultResponse
	
	export interface CompetitionControllerFindChessMatchResult400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResultDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.MatchSearchResponseDto[]
		headers?: undefined
	}
	
	export type CompetitionControllerGetChessLeaderboardResponse =
		| CompetitionControllerGetChessLeaderboardDefaultResponse
	
	export interface CompetitionControllerGetChessLeaderboardDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessLeaderboardResponseEntryDto[]
		headers?: undefined
	}
	
	export type CompetitionControllerGetChessMatchResultResponse =
		| CompetitionControllerGetChessMatchResult400Response
		| CompetitionControllerGetChessMatchResult401Response
		| CompetitionControllerGetChessMatchResult403Response
		| CompetitionControllerGetChessMatchResult404Response
		| CompetitionControllerGetChessMatchResult409Response
		| CompetitionControllerGetChessMatchResult422Response
		| CompetitionControllerGetChessMatchResult500Response
		| CompetitionControllerGetChessMatchResultDefaultResponse
	
	export interface CompetitionControllerGetChessMatchResult400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResultDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessMatchResultDto
		headers?: undefined
	}
	
	export type CompetitionControllerGetLatestChessCompetitionReportResponse =
		| CompetitionControllerGetLatestChessCompetitionReport400Response
		| CompetitionControllerGetLatestChessCompetitionReport401Response
		| CompetitionControllerGetLatestChessCompetitionReport403Response
		| CompetitionControllerGetLatestChessCompetitionReport404Response
		| CompetitionControllerGetLatestChessCompetitionReport409Response
		| CompetitionControllerGetLatestChessCompetitionReport422Response
		| CompetitionControllerGetLatestChessCompetitionReport500Response
		| CompetitionControllerGetLatestChessCompetitionReportDefaultResponse
	
	export interface CompetitionControllerGetLatestChessCompetitionReport400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReportDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.CompetitionRunSubmissionReportEntity[]
		headers?: undefined
	}
	
	export type CompetitionControllerListChessAgentsResponse =
		| CompetitionControllerListChessAgents400Response
		| CompetitionControllerListChessAgents401Response
		| CompetitionControllerListChessAgents403Response
		| CompetitionControllerListChessAgents404Response
		| CompetitionControllerListChessAgents409Response
		| CompetitionControllerListChessAgents422Response
		| CompetitionControllerListChessAgents500Response
		| CompetitionControllerListChessAgentsDefaultResponse
	
	export interface CompetitionControllerListChessAgents400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgentsDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessAgentResponseEntryDto[]
		headers?: undefined
	}
	
	export type CompetitionControllerRequestChessMoveResponse =
		| CompetitionControllerRequestChessMove400Response
		| CompetitionControllerRequestChessMove401Response
		| CompetitionControllerRequestChessMove403Response
		| CompetitionControllerRequestChessMove404Response
		| CompetitionControllerRequestChessMove409Response
		| CompetitionControllerRequestChessMove422Response
		| CompetitionControllerRequestChessMove500Response
		| CompetitionControllerRequestChessMoveDefaultResponse
	
	export interface CompetitionControllerRequestChessMove400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMoveDefaultResponse {
		status: number
		contentType: 'text/html'
		body: string
		headers?: undefined
	}
	
	export type CompetitionControllerRunChessMatchResponse =
		| CompetitionControllerRunChessMatch400Response
		| CompetitionControllerRunChessMatch401Response
		| CompetitionControllerRunChessMatch403Response
		| CompetitionControllerRunChessMatch404Response
		| CompetitionControllerRunChessMatch409Response
		| CompetitionControllerRunChessMatch422Response
		| CompetitionControllerRunChessMatch500Response
		| CompetitionControllerRunChessMatchDefaultResponse
	
	export interface CompetitionControllerRunChessMatch400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatchDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessMatchResultDto
		headers?: undefined
	}
	
	export type CompetitionControllerRunCompetitionResponse =
		| CompetitionControllerRunCompetition400Response
		| CompetitionControllerRunCompetition401Response
		| CompetitionControllerRunCompetition403Response
		| CompetitionControllerRunCompetition404Response
		| CompetitionControllerRunCompetition409Response
		| CompetitionControllerRunCompetition422Response
		| CompetitionControllerRunCompetition500Response
	
	export interface CompetitionControllerRunCompetition400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CompetitionControllerSubmitChessAgentResponse =
		| CompetitionControllerSubmitChessAgent400Response
		| CompetitionControllerSubmitChessAgent401Response
		| CompetitionControllerSubmitChessAgent403Response
		| CompetitionControllerSubmitChessAgent404Response
		| CompetitionControllerSubmitChessAgent409Response
		| CompetitionControllerSubmitChessAgent422Response
		| CompetitionControllerSubmitChessAgent500Response
		| CompetitionControllerSubmitChessAgentDefaultResponse
	
	export interface CompetitionControllerSubmitChessAgent400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgentDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.TerminalDto[]
		headers?: undefined
	}
	
}

/**
 * CompetitionsApi - fetch parameter creator
 * @export
 */
export const CompetitionsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerFindChessMatchResult.');
			}

			let localVarPath = `/Competitions/Chess/FindMatches`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/Leaderboard`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling competitionControllerGetChessMatchResult.');
			}

			let localVarPath = `/Competitions/Chess/Match/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/LatestCompetitionReport`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/ListAgents`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRequestChessMove.');
			}

			let localVarPath = `/Competitions/Chess/Move`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRunChessMatch.');
			}

			let localVarPath = `/Competitions/Chess/RunMatch`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/RunCompetition`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/submit`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			// localVarHeaderParameter.set('Content-Type', 'multipart/form-data'); // Commented out to let browser set boundary

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				const localVarFormData = new FormData();
				if (request.file !== undefined) {
					localVarFormData.append('file', request.file.value);
				}
				localVarRequestOptions.body = localVarFormData;
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * CompetitionsApi - functional programming interface
 * @export
 */
export const CompetitionsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerFindChessMatchResultResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerFindChessMatchResult(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.MatchSearchResponseDto[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetChessLeaderboardResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessLeaderboard(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessLeaderboardResponseEntryDto[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetChessMatchResultResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessMatchResult(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessMatchResultDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetLatestChessCompetitionReportResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetLatestChessCompetitionReport(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.CompetitionRunSubmissionReportEntity[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerListChessAgentsResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerListChessAgents(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessAgentResponseEntryDto[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRequestChessMoveResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRequestChessMove(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'text/html') {
					return {
						status: response.status,
						contentType: 'text/html',
						body: await response.text(),
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRunChessMatchResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunChessMatch(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessMatchResultDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRunCompetitionResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunCompetition(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerSubmitChessAgentResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerSubmitChessAgent(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.TerminalDto[],
					}
				}
				throw response;
			};
		},
	}
};

/**
 * CompetitionsApi - factory interface
 * @export
 */
export const CompetitionsApiFactory: FactoryFunction<CompetitionsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new CompetitionsApi(configuration, basePath, fetch);
};

/**
 * CompetitionsApi - interface
 * @export
 * @interface CompetitionsApi
 */
export interface CompetitionsApiInterface {
	/**
	 * @param {Api.MatchSearchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerFindChessMatchResultResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetChessLeaderboard(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetChessLeaderboardResponse>

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetChessMatchResult(id: string, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetChessMatchResultResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetLatestChessCompetitionReport(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetLatestChessCompetitionReportResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerListChessAgents(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerListChessAgentsResponse>

	/**
	 * @param {Api.ChessMoveRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRequestChessMoveResponse>

	/**
	 * @param {Api.ChessMatchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRunChessMatchResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRunCompetition(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRunCompetitionResponse>

	/**
	 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerSubmitChessAgentResponse>

}

/**
 * CompetitionsApi - object-oriented interface
 * @export
 * @class CompetitionsApi
 * @extends {BaseAPI}
 */
export class CompetitionsApi extends BaseAPI implements CompetitionsApiInterface {
	/**
	 * @param {Api.MatchSearchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerFindChessMatchResult(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessLeaderboard(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessLeaderboard(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessMatchResult(id: string, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessMatchResult(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetLatestChessCompetitionReport(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetLatestChessCompetitionReport(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerListChessAgents(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerListChessAgents(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMoveRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRequestChessMove(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMatchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunChessMatch(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunCompetition(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunCompetition(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerSubmitChessAgent(request, options)(this.fetch, this.basePath);
	}

}
export namespace ContentApi {
	export type ContentControllerCreateEmptyCourseResponse =
		| ContentControllerCreateEmptyCourse400Response
		| ContentControllerCreateEmptyCourse401Response
		| ContentControllerCreateEmptyCourse403Response
		| ContentControllerCreateEmptyCourse404Response
		| ContentControllerCreateEmptyCourse409Response
		| ContentControllerCreateEmptyCourse422Response
		| ContentControllerCreateEmptyCourse500Response
		| ContentControllerCreateEmptyCourseDefaultResponse
	
	export interface ContentControllerCreateEmptyCourse400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourseDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.CourseEntity
		headers?: undefined
	}
	
}

/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/content/course/create`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ContentApi.ContentControllerCreateEmptyCourseResponse> {
			const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentControllerCreateEmptyCourse(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.CourseEntity,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory: FactoryFunction<ContentApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ContentApi(configuration, basePath, fetch);
};

/**
 * ContentApi - interface
 * @export
 * @interface ContentApi
 */
export interface ContentApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	contentControllerCreateEmptyCourse(options?: RequestInit): Promise<ContentApi.ContentControllerCreateEmptyCourseResponse>

}

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI implements ContentApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public contentControllerCreateEmptyCourse(options?: RequestInit) {
		return ContentApiFp(this.configuration).contentControllerCreateEmptyCourse(options)(this.fetch, this.basePath);
	}

}
export namespace CoursesApi {
	export type CoursesControllerAddEditorResponse =
		| CoursesControllerAddEditor400Response
		| CoursesControllerAddEditor401Response
		| CoursesControllerAddEditor403Response
		| CoursesControllerAddEditor404Response
		| CoursesControllerAddEditor409Response
		| CoursesControllerAddEditor422Response
		| CoursesControllerAddEditor500Response
	
	export interface CoursesControllerAddEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerAddEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerCreateOneBaseResponse =
		| CoursesControllerCreateOneBase400Response
		| CoursesControllerCreateOneBase401Response
		| CoursesControllerCreateOneBase403Response
		| CoursesControllerCreateOneBase404Response
		| CoursesControllerCreateOneBase409Response
		| CoursesControllerCreateOneBase422Response
		| CoursesControllerCreateOneBase500Response
	
	export interface CoursesControllerCreateOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerCreateOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerDeleteOneBaseResponse =
		| CoursesControllerDeleteOneBase400Response
		| CoursesControllerDeleteOneBase401Response
		| CoursesControllerDeleteOneBase403Response
		| CoursesControllerDeleteOneBase404Response
		| CoursesControllerDeleteOneBase409Response
		| CoursesControllerDeleteOneBase422Response
		| CoursesControllerDeleteOneBase500Response
	
	export interface CoursesControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerGetManyBaseResponse =
		| CoursesControllerGetManyBase400Response
		| CoursesControllerGetManyBase422Response
		| CoursesControllerGetManyBase500Response
	
	export interface CoursesControllerGetManyBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerGetManyBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerGetManyBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerGetOneBaseResponse =
		| CoursesControllerGetOneBase400Response
		| CoursesControllerGetOneBase422Response
		| CoursesControllerGetOneBase500Response
	
	export interface CoursesControllerGetOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerGetOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerGetOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerICanEditResponse =
		| CoursesControllerICanEdit200Response
		| CoursesControllerICanEdit400Response
		| CoursesControllerICanEdit401Response
		| CoursesControllerICanEdit403Response
		| CoursesControllerICanEdit404Response
		| CoursesControllerICanEdit409Response
		| CoursesControllerICanEdit422Response
		| CoursesControllerICanEdit500Response
	
	export interface CoursesControllerICanEdit200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerICanEdit500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerOwnedByMeResponse =
		| CoursesControllerOwnedByMe200Response
		| CoursesControllerOwnedByMe400Response
		| CoursesControllerOwnedByMe401Response
		| CoursesControllerOwnedByMe403Response
		| CoursesControllerOwnedByMe404Response
		| CoursesControllerOwnedByMe409Response
		| CoursesControllerOwnedByMe422Response
		| CoursesControllerOwnedByMe500Response
	
	export interface CoursesControllerOwnedByMe200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerOwnedByMe500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerRemoveEditorResponse =
		| CoursesControllerRemoveEditor400Response
		| CoursesControllerRemoveEditor401Response
		| CoursesControllerRemoveEditor403Response
		| CoursesControllerRemoveEditor404Response
		| CoursesControllerRemoveEditor409Response
		| CoursesControllerRemoveEditor422Response
		| CoursesControllerRemoveEditor500Response
	
	export interface CoursesControllerRemoveEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerRemoveEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerSwitchOwnerResponse =
		| CoursesControllerSwitchOwner400Response
		| CoursesControllerSwitchOwner401Response
		| CoursesControllerSwitchOwner403Response
		| CoursesControllerSwitchOwner404Response
		| CoursesControllerSwitchOwner409Response
		| CoursesControllerSwitchOwner422Response
		| CoursesControllerSwitchOwner500Response
	
	export interface CoursesControllerSwitchOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerSwitchOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CoursesControllerUpdateOneBaseResponse =
		| CoursesControllerUpdateOneBase400Response
		| CoursesControllerUpdateOneBase401Response
		| CoursesControllerUpdateOneBase403Response
		| CoursesControllerUpdateOneBase404Response
		| CoursesControllerUpdateOneBase409Response
		| CoursesControllerUpdateOneBase422Response
		| CoursesControllerUpdateOneBase500Response
	
	export interface CoursesControllerUpdateOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CoursesControllerUpdateOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * CoursesApi - fetch parameter creator
 * @export
 */
export const CoursesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling coursesControllerAddEditor.');
			}

			let localVarPath = `/courses/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CourseEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerCreateOneBase(request: Api.CourseEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling coursesControllerCreateOneBase.');
			}

			let localVarPath = `/courses`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/{slug}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/{slug}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerICanEdit(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/get-editable-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerOwnedByMe(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/get-owned-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling coursesControllerRemoveEditor.');
			}

			let localVarPath = `/courses/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling coursesControllerSwitchOwner.');
			}

			let localVarPath = `/courses/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CourseEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerUpdateOneBase(request: Api.CourseEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling coursesControllerUpdateOneBase.');
			}

			let localVarPath = `/courses/{slug}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerAddEditorResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerAddEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CourseEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerCreateOneBase(request: Api.CourseEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerCreateOneBaseResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerCreateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerGetManyBaseResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerGetOneBaseResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerICanEdit(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerICanEditResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerICanEdit(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerOwnedByMe(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerOwnedByMeResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerOwnedByMe(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerRemoveEditorResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerRemoveEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerSwitchOwnerResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerSwitchOwner(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CourseEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesControllerUpdateOneBase(request: Api.CourseEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CoursesApi.CoursesControllerUpdateOneBaseResponse> {
			const localVarFetchArgs = CoursesApiFetchParamCreator(configuration).coursesControllerUpdateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory: FactoryFunction<CoursesApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new CoursesApi(configuration, basePath, fetch);
};

/**
 * CoursesApi - interface
 * @export
 * @interface CoursesApi
 */
export interface CoursesApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<CoursesApi.CoursesControllerAddEditorResponse>

	/**
	 * @param {Api.CourseEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerCreateOneBase(request: Api.CourseEntity, options?: RequestInit): Promise<CoursesApi.CoursesControllerCreateOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerDeleteOneBase(options?: RequestInit): Promise<CoursesApi.CoursesControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerGetManyBase(options?: RequestInit): Promise<CoursesApi.CoursesControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerGetOneBase(options?: RequestInit): Promise<CoursesApi.CoursesControllerGetOneBaseResponse>

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerICanEdit(options?: RequestInit): Promise<CoursesApi.CoursesControllerICanEditResponse>

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerOwnedByMe(options?: RequestInit): Promise<CoursesApi.CoursesControllerOwnedByMeResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<CoursesApi.CoursesControllerRemoveEditorResponse>

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): Promise<CoursesApi.CoursesControllerSwitchOwnerResponse>

	/**
	 * @param {Api.CourseEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	coursesControllerUpdateOneBase(request: Api.CourseEntity, options?: RequestInit): Promise<CoursesApi.CoursesControllerUpdateOneBaseResponse>

}

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI implements CoursesApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CourseEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerCreateOneBase(request: Api.CourseEntity, options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerCreateOneBase(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerDeleteOneBase(options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerGetManyBase(options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerGetOneBase(options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerGetOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerICanEdit(options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerICanEdit(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerOwnedByMe(options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerOwnedByMe(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CourseEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesControllerUpdateOneBase(request: Api.CourseEntity, options?: RequestInit) {
		return CoursesApiFp(this.configuration).coursesControllerUpdateOneBase(request, options)(this.fetch, this.basePath);
	}

}
export namespace HealthcheckApi {
	export type HealthcheckControllerDbResponse =
		| HealthcheckControllerDb200Response
		| HealthcheckControllerDb500Response
	
	export interface HealthcheckControllerDb200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface HealthcheckControllerDb500Response {
		status: 500
		body?: undefined
		headers?: undefined
	}
	
	export type HealthcheckControllerRedisResponse =
		| HealthcheckControllerRedis200Response
		| HealthcheckControllerRedis500Response
	
	export interface HealthcheckControllerRedis200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface HealthcheckControllerRedis500Response {
		status: 500
		body?: undefined
		headers?: undefined
	}
	
	export type HealthcheckControllerS3Response =
		| HealthcheckControllerS3200Response
		| HealthcheckControllerS3500Response
	
	export interface HealthcheckControllerS3200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface HealthcheckControllerS3500Response {
		status: 500
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * HealthcheckApi - fetch parameter creator
 * @export
 */
export const HealthcheckApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerDb(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/healthcheck/db`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerRedis(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/healthcheck/redis`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerS3(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/healthcheck/s3`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * HealthcheckApi - functional programming interface
 * @export
 */
export const HealthcheckApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerDb(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<HealthcheckApi.HealthcheckControllerDbResponse> {
			const localVarFetchArgs = HealthcheckApiFetchParamCreator(configuration).healthcheckControllerDb(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 500) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerRedis(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<HealthcheckApi.HealthcheckControllerRedisResponse> {
			const localVarFetchArgs = HealthcheckApiFetchParamCreator(configuration).healthcheckControllerRedis(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 500) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthcheckControllerS3(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<HealthcheckApi.HealthcheckControllerS3Response> {
			const localVarFetchArgs = HealthcheckApiFetchParamCreator(configuration).healthcheckControllerS3(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 500) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * HealthcheckApi - factory interface
 * @export
 */
export const HealthcheckApiFactory: FactoryFunction<HealthcheckApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new HealthcheckApi(configuration, basePath, fetch);
};

/**
 * HealthcheckApi - interface
 * @export
 * @interface HealthcheckApi
 */
export interface HealthcheckApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	healthcheckControllerDb(options?: RequestInit): Promise<HealthcheckApi.HealthcheckControllerDbResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	healthcheckControllerRedis(options?: RequestInit): Promise<HealthcheckApi.HealthcheckControllerRedisResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	healthcheckControllerS3(options?: RequestInit): Promise<HealthcheckApi.HealthcheckControllerS3Response>

}

/**
 * HealthcheckApi - object-oriented interface
 * @export
 * @class HealthcheckApi
 * @extends {BaseAPI}
 */
export class HealthcheckApi extends BaseAPI implements HealthcheckApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public healthcheckControllerDb(options?: RequestInit) {
		return HealthcheckApiFp(this.configuration).healthcheckControllerDb(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public healthcheckControllerRedis(options?: RequestInit) {
		return HealthcheckApiFp(this.configuration).healthcheckControllerRedis(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public healthcheckControllerS3(options?: RequestInit) {
		return HealthcheckApiFp(this.configuration).healthcheckControllerS3(options)(this.fetch, this.basePath);
	}

}
export namespace JobApplicationsApi {
	export type JobApplicationControllerAdvanceCandidateResponse =
		| JobApplicationControllerAdvanceCandidate200Response
		| JobApplicationControllerAdvanceCandidate400Response
		| JobApplicationControllerAdvanceCandidate401Response
		| JobApplicationControllerAdvanceCandidate403Response
		| JobApplicationControllerAdvanceCandidate404Response
		| JobApplicationControllerAdvanceCandidate409Response
		| JobApplicationControllerAdvanceCandidate422Response
		| JobApplicationControllerAdvanceCandidate500Response
	
	export interface JobApplicationControllerAdvanceCandidate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerAdvanceCandidate500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerCreateOneResponse =
		| JobApplicationControllerCreateOne400Response
		| JobApplicationControllerCreateOne401Response
		| JobApplicationControllerCreateOne403Response
		| JobApplicationControllerCreateOne404Response
		| JobApplicationControllerCreateOne409Response
		| JobApplicationControllerCreateOne422Response
		| JobApplicationControllerCreateOne500Response
	
	export interface JobApplicationControllerCreateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerCreateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerDeleteOneBaseResponse =
		| JobApplicationControllerDeleteOneBase400Response
		| JobApplicationControllerDeleteOneBase401Response
		| JobApplicationControllerDeleteOneBase403Response
		| JobApplicationControllerDeleteOneBase404Response
		| JobApplicationControllerDeleteOneBase409Response
		| JobApplicationControllerDeleteOneBase422Response
		| JobApplicationControllerDeleteOneBase500Response
	
	export interface JobApplicationControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerGetManyBaseResponse =
		| JobApplicationControllerGetManyBase400Response
		| JobApplicationControllerGetManyBase401Response
		| JobApplicationControllerGetManyBase403Response
		| JobApplicationControllerGetManyBase404Response
		| JobApplicationControllerGetManyBase409Response
		| JobApplicationControllerGetManyBase422Response
		| JobApplicationControllerGetManyBase500Response
	
	export interface JobApplicationControllerGetManyBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetManyBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerGetOneBaseResponse =
		| JobApplicationControllerGetOneBase400Response
		| JobApplicationControllerGetOneBase401Response
		| JobApplicationControllerGetOneBase403Response
		| JobApplicationControllerGetOneBase404Response
		| JobApplicationControllerGetOneBase409Response
		| JobApplicationControllerGetOneBase422Response
		| JobApplicationControllerGetOneBase500Response
	
	export interface JobApplicationControllerGetOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerGetOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerMoveBackCandidateResponse =
		| JobApplicationControllerMoveBackCandidate200Response
		| JobApplicationControllerMoveBackCandidate400Response
		| JobApplicationControllerMoveBackCandidate401Response
		| JobApplicationControllerMoveBackCandidate403Response
		| JobApplicationControllerMoveBackCandidate404Response
		| JobApplicationControllerMoveBackCandidate409Response
		| JobApplicationControllerMoveBackCandidate422Response
		| JobApplicationControllerMoveBackCandidate500Response
	
	export interface JobApplicationControllerMoveBackCandidate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMoveBackCandidate500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerMyApplicationBySlugResponse =
		| JobApplicationControllerMyApplicationBySlug200Response
		| JobApplicationControllerMyApplicationBySlug400Response
		| JobApplicationControllerMyApplicationBySlug401Response
		| JobApplicationControllerMyApplicationBySlug403Response
		| JobApplicationControllerMyApplicationBySlug404Response
		| JobApplicationControllerMyApplicationBySlug409Response
		| JobApplicationControllerMyApplicationBySlug422Response
		| JobApplicationControllerMyApplicationBySlug500Response
	
	export interface JobApplicationControllerMyApplicationBySlug200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplicationBySlug500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerMyApplicationsResponse =
		| JobApplicationControllerMyApplications200Response
		| JobApplicationControllerMyApplications400Response
		| JobApplicationControllerMyApplications401Response
		| JobApplicationControllerMyApplications403Response
		| JobApplicationControllerMyApplications404Response
		| JobApplicationControllerMyApplications409Response
		| JobApplicationControllerMyApplications422Response
		| JobApplicationControllerMyApplications500Response
	
	export interface JobApplicationControllerMyApplications200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity[]
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerMyApplications500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerRejectCandidateResponse =
		| JobApplicationControllerRejectCandidate200Response
		| JobApplicationControllerRejectCandidate400Response
		| JobApplicationControllerRejectCandidate401Response
		| JobApplicationControllerRejectCandidate403Response
		| JobApplicationControllerRejectCandidate404Response
		| JobApplicationControllerRejectCandidate409Response
		| JobApplicationControllerRejectCandidate422Response
		| JobApplicationControllerRejectCandidate500Response
	
	export interface JobApplicationControllerRejectCandidate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerRejectCandidate500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerUndoRejectCandidateResponse =
		| JobApplicationControllerUndoRejectCandidate200Response
		| JobApplicationControllerUndoRejectCandidate400Response
		| JobApplicationControllerUndoRejectCandidate401Response
		| JobApplicationControllerUndoRejectCandidate403Response
		| JobApplicationControllerUndoRejectCandidate404Response
		| JobApplicationControllerUndoRejectCandidate409Response
		| JobApplicationControllerUndoRejectCandidate422Response
		| JobApplicationControllerUndoRejectCandidate500Response
	
	export interface JobApplicationControllerUndoRejectCandidate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUndoRejectCandidate500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerUpdateOneResponse =
		| JobApplicationControllerUpdateOne400Response
		| JobApplicationControllerUpdateOne401Response
		| JobApplicationControllerUpdateOne403Response
		| JobApplicationControllerUpdateOne404Response
		| JobApplicationControllerUpdateOne409Response
		| JobApplicationControllerUpdateOne422Response
		| JobApplicationControllerUpdateOne500Response
	
	export interface JobApplicationControllerUpdateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerUpdateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobApplicationControllerWithdrawResponse =
		| JobApplicationControllerWithdraw200Response
		| JobApplicationControllerWithdraw400Response
		| JobApplicationControllerWithdraw401Response
		| JobApplicationControllerWithdraw403Response
		| JobApplicationControllerWithdraw404Response
		| JobApplicationControllerWithdraw409Response
		| JobApplicationControllerWithdraw422Response
		| JobApplicationControllerWithdraw500Response
	
	export interface JobApplicationControllerWithdraw200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobApplicationControllerWithdraw500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobApplicationsApi - fetch parameter creator
 * @export
 */
export const JobApplicationsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerAdvanceCandidate(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerAdvanceCandidate.');
			}

			let localVarPath = `/job-applications/advance-candidate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobAplicationCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerCreateOne(request: Api.JobAplicationCreateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerCreateOne.');
			}

			let localVarPath = `/job-applications`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-applications/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-applications`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-applications/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMoveBackCandidate(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerMoveBackCandidate.');
			}

			let localVarPath = `/job-applications/undo-advance-candidate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMyApplicationBySlug(slug: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'slug' is not null or undefined
			if (slug === null || slug === undefined) {
				throw new RequiredError('slug', 'Required parameter slug was null or undefined when calling jobApplicationControllerMyApplicationBySlug.');
			}

			let localVarPath = `/job-applications/my-application-by-slug/{slug}`
				.replace('{slug}', encodeURIComponent(String(slug)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMyApplications(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-applications/my-applications`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerRejectCandidate(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerRejectCandidate.');
			}

			let localVarPath = `/job-applications/reject-candidate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerUndoRejectCandidate(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerUndoRejectCandidate.');
			}

			let localVarPath = `/job-applications/undo-reject-candidate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerUpdateOne(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerUpdateOne.');
			}

			let localVarPath = `/job-applications/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerWithdraw(request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobApplicationControllerWithdraw.');
			}

			let localVarPath = `/job-applications/withdraw`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobApplicationsApi - functional programming interface
 * @export
 */
export const JobApplicationsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerAdvanceCandidate(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerAdvanceCandidateResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerAdvanceCandidate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobAplicationCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerCreateOne(request: Api.JobAplicationCreateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerCreateOneResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerCreateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerGetManyBaseResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerGetOneBaseResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMoveBackCandidate(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerMoveBackCandidateResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerMoveBackCandidate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMyApplicationBySlug(slug: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerMyApplicationBySlugResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerMyApplicationBySlug(slug, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerMyApplications(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerMyApplicationsResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerMyApplications(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerRejectCandidateResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerRejectCandidate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerUndoRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerUndoRejectCandidateResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerUndoRejectCandidate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerUpdateOne(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerUpdateOneResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerUpdateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobApplicationControllerWithdraw(request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.JobApplicationControllerWithdrawResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).jobApplicationControllerWithdraw(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobApplicationsApi - factory interface
 * @export
 */
export const JobApplicationsApiFactory: FactoryFunction<JobApplicationsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobApplicationsApi(configuration, basePath, fetch);
};

/**
 * JobApplicationsApi - interface
 * @export
 * @interface JobApplicationsApi
 */
export interface JobApplicationsApiInterface {
	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerAdvanceCandidate(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerAdvanceCandidateResponse>

	/**
	 * @param {Api.JobAplicationCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerCreateOne(request: Api.JobAplicationCreateDto, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerCreateOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerDeleteOneBase(options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerGetManyBase(options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerGetOneBase(options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerGetOneBaseResponse>

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerMoveBackCandidate(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerMoveBackCandidateResponse>

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerMyApplicationBySlug(slug: string, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerMyApplicationBySlugResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerMyApplications(options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerMyApplicationsResponse>

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerRejectCandidateResponse>

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerUndoRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerUndoRejectCandidateResponse>

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerUpdateOne(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerUpdateOneResponse>

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobApplicationControllerWithdraw(request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.JobApplicationControllerWithdrawResponse>

}

/**
 * JobApplicationsApi - object-oriented interface
 * @export
 * @class JobApplicationsApi
 * @extends {BaseAPI}
 */
export class JobApplicationsApi extends BaseAPI implements JobApplicationsApiInterface {
	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerAdvanceCandidate(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerAdvanceCandidate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobAplicationCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerCreateOne(request: Api.JobAplicationCreateDto, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerCreateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerDeleteOneBase(options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerGetManyBase(options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerGetOneBase(options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerGetOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerMoveBackCandidate(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerMoveBackCandidate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerMyApplicationBySlug(slug: string, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerMyApplicationBySlug(slug, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerMyApplications(options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerMyApplications(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerRejectCandidate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerUndoRejectCandidate(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerUndoRejectCandidate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerUpdateOne(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerUpdateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobApplicationControllerWithdraw(request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).jobApplicationControllerWithdraw(request, options)(this.fetch, this.basePath);
	}

}
export namespace JobPostsApi {
	export type JobPostControllerAddEditorResponse =
		| JobPostControllerAddEditor400Response
		| JobPostControllerAddEditor401Response
		| JobPostControllerAddEditor403Response
		| JobPostControllerAddEditor404Response
		| JobPostControllerAddEditor409Response
		| JobPostControllerAddEditor422Response
		| JobPostControllerAddEditor500Response
	
	export interface JobPostControllerAddEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerCreateOneResponse =
		| JobPostControllerCreateOne400Response
		| JobPostControllerCreateOne401Response
		| JobPostControllerCreateOne403Response
		| JobPostControllerCreateOne404Response
		| JobPostControllerCreateOne409Response
		| JobPostControllerCreateOne422Response
		| JobPostControllerCreateOne500Response
	
	export interface JobPostControllerCreateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerCreateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerDeleteOneBaseResponse =
		| JobPostControllerDeleteOneBase400Response
		| JobPostControllerDeleteOneBase401Response
		| JobPostControllerDeleteOneBase403Response
		| JobPostControllerDeleteOneBase404Response
		| JobPostControllerDeleteOneBase409Response
		| JobPostControllerDeleteOneBase422Response
		| JobPostControllerDeleteOneBase500Response
	
	export interface JobPostControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerGetBySlugResponse =
		| JobPostControllerGetBySlug200Response
		| JobPostControllerGetBySlug400Response
		| JobPostControllerGetBySlug401Response
		| JobPostControllerGetBySlug403Response
		| JobPostControllerGetBySlug404Response
		| JobPostControllerGetBySlug409Response
		| JobPostControllerGetBySlug422Response
		| JobPostControllerGetBySlug500Response
	
	export interface JobPostControllerGetBySlug200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobPostEntity
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlug500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerGetBySlugForOwnerResponse =
		| JobPostControllerGetBySlugForOwner200Response
		| JobPostControllerGetBySlugForOwner400Response
		| JobPostControllerGetBySlugForOwner401Response
		| JobPostControllerGetBySlugForOwner403Response
		| JobPostControllerGetBySlugForOwner404Response
		| JobPostControllerGetBySlugForOwner409Response
		| JobPostControllerGetBySlugForOwner422Response
		| JobPostControllerGetBySlugForOwner500Response
	
	export interface JobPostControllerGetBySlugForOwner200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobPostEntity
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetBySlugForOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerGetManyBaseResponse =
		| JobPostControllerGetManyBase200Response
	
	export interface JobPostControllerGetManyBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type JobPostControllerGetManyWithAppliedResponse =
		| JobPostControllerGetManyWithApplied200Response
		| JobPostControllerGetManyWithApplied400Response
		| JobPostControllerGetManyWithApplied401Response
		| JobPostControllerGetManyWithApplied403Response
		| JobPostControllerGetManyWithApplied404Response
		| JobPostControllerGetManyWithApplied409Response
		| JobPostControllerGetManyWithApplied422Response
		| JobPostControllerGetManyWithApplied500Response
	
	export interface JobPostControllerGetManyWithApplied200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobPostWithAppliedDto[]
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetManyWithApplied500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerGetOneBaseResponse =
		| JobPostControllerGetOneBase400Response
		| JobPostControllerGetOneBase401Response
		| JobPostControllerGetOneBase403Response
		| JobPostControllerGetOneBase404Response
		| JobPostControllerGetOneBase409Response
		| JobPostControllerGetOneBase422Response
		| JobPostControllerGetOneBase500Response
	
	export interface JobPostControllerGetOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerGetOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerICanEditResponse =
		| JobPostControllerICanEdit200Response
		| JobPostControllerICanEdit400Response
		| JobPostControllerICanEdit401Response
		| JobPostControllerICanEdit403Response
		| JobPostControllerICanEdit404Response
		| JobPostControllerICanEdit409Response
		| JobPostControllerICanEdit422Response
		| JobPostControllerICanEdit500Response
	
	export interface JobPostControllerICanEdit200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerICanEdit500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerOwnedByMeResponse =
		| JobPostControllerOwnedByMe200Response
		| JobPostControllerOwnedByMe400Response
		| JobPostControllerOwnedByMe401Response
		| JobPostControllerOwnedByMe403Response
		| JobPostControllerOwnedByMe404Response
		| JobPostControllerOwnedByMe409Response
		| JobPostControllerOwnedByMe422Response
		| JobPostControllerOwnedByMe500Response
	
	export interface JobPostControllerOwnedByMe200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerOwnedByMe500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerRemoveEditorResponse =
		| JobPostControllerRemoveEditor400Response
		| JobPostControllerRemoveEditor401Response
		| JobPostControllerRemoveEditor403Response
		| JobPostControllerRemoveEditor404Response
		| JobPostControllerRemoveEditor409Response
		| JobPostControllerRemoveEditor422Response
		| JobPostControllerRemoveEditor500Response
	
	export interface JobPostControllerRemoveEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerSwitchOwnerResponse =
		| JobPostControllerSwitchOwner400Response
		| JobPostControllerSwitchOwner401Response
		| JobPostControllerSwitchOwner403Response
		| JobPostControllerSwitchOwner404Response
		| JobPostControllerSwitchOwner409Response
		| JobPostControllerSwitchOwner422Response
		| JobPostControllerSwitchOwner500Response
	
	export interface JobPostControllerSwitchOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerUpdateOneResponse =
		| JobPostControllerUpdateOne400Response
		| JobPostControllerUpdateOne401Response
		| JobPostControllerUpdateOne403Response
		| JobPostControllerUpdateOne404Response
		| JobPostControllerUpdateOne409Response
		| JobPostControllerUpdateOne422Response
		| JobPostControllerUpdateOne500Response
	
	export interface JobPostControllerUpdateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerUpdateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobPostsApi - fetch parameter creator
 * @export
 */
export const JobPostsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerAddEditor.');
			}

			let localVarPath = `/job-posts/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobPostCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerCreateOne(request: Api.JobPostCreateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerCreateOne.');
			}

			let localVarPath = `/job-posts`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetBySlug(slug: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'slug' is not null or undefined
			if (slug === null || slug === undefined) {
				throw new RequiredError('slug', 'Required parameter slug was null or undefined when calling jobPostControllerGetBySlug.');
			}

			let localVarPath = `/job-posts/get-by-slug/{slug}`
				.replace('{slug}', encodeURIComponent(String(slug)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetBySlugForOwner(slug: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'slug' is not null or undefined
			if (slug === null || slug === undefined) {
				throw new RequiredError('slug', 'Required parameter slug was null or undefined when calling jobPostControllerGetBySlugForOwner.');
			}

			let localVarPath = `/job-posts/get-by-slug-for-owner/{slug}`
				.replace('{slug}', encodeURIComponent(String(slug)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetManyWithApplied(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts/get-many-with-applied`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerICanEdit(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts/get-editable-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerOwnedByMe(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts/get-owned-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerRemoveEditor.');
			}

			let localVarPath = `/job-posts/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerSwitchOwner.');
			}

			let localVarPath = `/job-posts/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobPostEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerUpdateOne(request: Api.JobPostEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerUpdateOne.');
			}

			let localVarPath = `/job-posts/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobPostsApi - functional programming interface
 * @export
 */
export const JobPostsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerAddEditorResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerAddEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobPostCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerCreateOne(request: Api.JobPostCreateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerCreateOneResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerCreateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetBySlug(slug: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerGetBySlugResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerGetBySlug(slug, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetBySlugForOwner(slug: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerGetBySlugForOwnerResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerGetBySlugForOwner(slug, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerGetManyBaseResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetManyWithApplied(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerGetManyWithAppliedResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerGetManyWithApplied(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostWithAppliedDto[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerGetOneBaseResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerICanEdit(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerICanEditResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerICanEdit(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerOwnedByMe(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerOwnedByMeResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerOwnedByMe(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerRemoveEditorResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerRemoveEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerSwitchOwnerResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerSwitchOwner(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobPostEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerUpdateOne(request: Api.JobPostEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerUpdateOneResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerUpdateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobPostsApi - factory interface
 * @export
 */
export const JobPostsApiFactory: FactoryFunction<JobPostsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobPostsApi(configuration, basePath, fetch);
};

/**
 * JobPostsApi - interface
 * @export
 * @interface JobPostsApi
 */
export interface JobPostsApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerAddEditorResponse>

	/**
	 * @param {Api.JobPostCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerCreateOne(request: Api.JobPostCreateDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerCreateOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerDeleteOneBase(options?: RequestInit): Promise<JobPostsApi.JobPostControllerDeleteOneBaseResponse>

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerGetBySlug(slug: string, options?: RequestInit): Promise<JobPostsApi.JobPostControllerGetBySlugResponse>

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerGetBySlugForOwner(slug: string, options?: RequestInit): Promise<JobPostsApi.JobPostControllerGetBySlugForOwnerResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerGetManyBase(options?: RequestInit): Promise<JobPostsApi.JobPostControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerGetManyWithApplied(options?: RequestInit): Promise<JobPostsApi.JobPostControllerGetManyWithAppliedResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerGetOneBase(options?: RequestInit): Promise<JobPostsApi.JobPostControllerGetOneBaseResponse>

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerICanEdit(options?: RequestInit): Promise<JobPostsApi.JobPostControllerICanEditResponse>

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerOwnedByMe(options?: RequestInit): Promise<JobPostsApi.JobPostControllerOwnedByMeResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerRemoveEditorResponse>

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerSwitchOwnerResponse>

	/**
	 * @param {Api.JobPostEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerUpdateOne(request: Api.JobPostEntity, options?: RequestInit): Promise<JobPostsApi.JobPostControllerUpdateOneResponse>

}

/**
 * JobPostsApi - object-oriented interface
 * @export
 * @class JobPostsApi
 * @extends {BaseAPI}
 */
export class JobPostsApi extends BaseAPI implements JobPostsApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobPostCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerCreateOne(request: Api.JobPostCreateDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerCreateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerDeleteOneBase(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerGetBySlug(slug: string, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerGetBySlug(slug, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerGetBySlugForOwner(slug: string, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerGetBySlugForOwner(slug, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerGetManyBase(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerGetManyWithApplied(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerGetManyWithApplied(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerGetOneBase(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerGetOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerICanEdit(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerICanEdit(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerOwnedByMe(options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerOwnedByMe(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobPostEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerUpdateOne(request: Api.JobPostEntity, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerUpdateOne(request, options)(this.fetch, this.basePath);
	}

}
export namespace JobTagsApi {
	export type JobTagControllerCreateOneBaseResponse =
		| JobTagControllerCreateOneBase400Response
		| JobTagControllerCreateOneBase401Response
		| JobTagControllerCreateOneBase403Response
		| JobTagControllerCreateOneBase404Response
		| JobTagControllerCreateOneBase409Response
		| JobTagControllerCreateOneBase422Response
		| JobTagControllerCreateOneBase500Response
	
	export interface JobTagControllerCreateOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerCreateOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobTagControllerDeleteOneBaseResponse =
		| JobTagControllerDeleteOneBase400Response
		| JobTagControllerDeleteOneBase401Response
		| JobTagControllerDeleteOneBase403Response
		| JobTagControllerDeleteOneBase404Response
		| JobTagControllerDeleteOneBase409Response
		| JobTagControllerDeleteOneBase422Response
		| JobTagControllerDeleteOneBase500Response
	
	export interface JobTagControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobTagControllerGetManyBaseResponse =
		| JobTagControllerGetManyBase200Response
	
	export interface JobTagControllerGetManyBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type JobTagControllerGetOneBaseResponse =
		| JobTagControllerGetOneBase400Response
		| JobTagControllerGetOneBase401Response
		| JobTagControllerGetOneBase403Response
		| JobTagControllerGetOneBase404Response
		| JobTagControllerGetOneBase409Response
		| JobTagControllerGetOneBase422Response
		| JobTagControllerGetOneBase500Response
	
	export interface JobTagControllerGetOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerGetOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobTagControllerUpdateOneBaseResponse =
		| JobTagControllerUpdateOneBase400Response
		| JobTagControllerUpdateOneBase401Response
		| JobTagControllerUpdateOneBase403Response
		| JobTagControllerUpdateOneBase404Response
		| JobTagControllerUpdateOneBase409Response
		| JobTagControllerUpdateOneBase422Response
		| JobTagControllerUpdateOneBase500Response
	
	export interface JobTagControllerUpdateOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobTagControllerUpdateOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobTagsApi - fetch parameter creator
 * @export
 */
export const JobTagsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerCreateOneBase(request: Api.JobTagEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobTagControllerCreateOneBase.');
			}

			let localVarPath = `/job-tags`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-tags/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-tags`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-tags/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerUpdateOneBase(request: Api.JobTagEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobTagControllerUpdateOneBase.');
			}

			let localVarPath = `/job-tags/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobTagsApi - functional programming interface
 * @export
 */
export const JobTagsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerCreateOneBase(request: Api.JobTagEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.JobTagControllerCreateOneBaseResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).jobTagControllerCreateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.JobTagControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).jobTagControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.JobTagControllerGetManyBaseResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).jobTagControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.JobTagControllerGetOneBaseResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).jobTagControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobTagControllerUpdateOneBase(request: Api.JobTagEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.JobTagControllerUpdateOneBaseResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).jobTagControllerUpdateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobTagsApi - factory interface
 * @export
 */
export const JobTagsApiFactory: FactoryFunction<JobTagsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobTagsApi(configuration, basePath, fetch);
};

/**
 * JobTagsApi - interface
 * @export
 * @interface JobTagsApi
 */
export interface JobTagsApiInterface {
	/**
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobTagControllerCreateOneBase(request: Api.JobTagEntity, options?: RequestInit): Promise<JobTagsApi.JobTagControllerCreateOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobTagControllerDeleteOneBase(options?: RequestInit): Promise<JobTagsApi.JobTagControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobTagControllerGetManyBase(options?: RequestInit): Promise<JobTagsApi.JobTagControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobTagControllerGetOneBase(options?: RequestInit): Promise<JobTagsApi.JobTagControllerGetOneBaseResponse>

	/**
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobTagControllerUpdateOneBase(request: Api.JobTagEntity, options?: RequestInit): Promise<JobTagsApi.JobTagControllerUpdateOneBaseResponse>

}

/**
 * JobTagsApi - object-oriented interface
 * @export
 * @class JobTagsApi
 * @extends {BaseAPI}
 */
export class JobTagsApi extends BaseAPI implements JobTagsApiInterface {
	/**
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobTagControllerCreateOneBase(request: Api.JobTagEntity, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).jobTagControllerCreateOneBase(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobTagControllerDeleteOneBase(options?: RequestInit) {
		return JobTagsApiFp(this.configuration).jobTagControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobTagControllerGetManyBase(options?: RequestInit) {
		return JobTagsApiFp(this.configuration).jobTagControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobTagControllerGetOneBase(options?: RequestInit) {
		return JobTagsApiFp(this.configuration).jobTagControllerGetOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobTagControllerUpdateOneBase(request: Api.JobTagEntity, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).jobTagControllerUpdateOneBase(request, options)(this.fetch, this.basePath);
	}

}
export namespace ProgramsApi {
	export interface ProgramControllerAssignRoleParameters {
		/**
		 * @description <p>Program UUID</p>
		 * @type {string}
		 */
		id: string
		/**
		 * @description <p>User UUID</p>
		 * @type {string}
		 */
		userId: string
	}
	
	export type ProgramControllerAssignRoleResponse =
		| ProgramControllerAssignRole201Response
		| ProgramControllerAssignRole403Response
	
	export interface ProgramControllerAssignRole201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerAssignRole403Response {
		status: 403
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerCheckAccessResponse =
		| ProgramControllerCheckAccess200Response
	
	export interface ProgramControllerCheckAccess200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerCreateResponse =
		| ProgramControllerCreate201Response
		| ProgramControllerCreate400Response
		| ProgramControllerCreate401Response
	
	export interface ProgramControllerCreate201Response {
		status: 201
		contentType: 'application/json'
		body: Api.Program
		headers?: undefined
	}
	
	export interface ProgramControllerCreate400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerCreate401Response {
		status: 401
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerEnrollResponse =
		| ProgramControllerEnroll201Response
		| ProgramControllerEnroll400Response
		| ProgramControllerEnroll404Response
	
	export interface ProgramControllerEnroll201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerEnroll400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerEnroll404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerFindAllParameters {
		/**
		 * @description <p>Filter by tags (comma-separated)</p>
		 * @type {unknown}
		 */
		tags?: unknown
		/**
		 * @description <p>Search in title and description</p>
		 * @type {unknown}
		 */
		search?: unknown
		/**
		 * @description <p>Filter by active/inactive programs</p>
		 * @type {unknown}
		 */
		isActive?: unknown
		/**
		 * @description <p>Filter by public/private programs</p>
		 * @type {unknown}
		 */
		isPublic?: unknown
		/**
		 * @description <p>Filter by difficulty level</p>
		 * @type {unknown}
		 */
		difficultyLevel?: unknown
	}
	
	export type ProgramControllerFindAllResponse =
		| ProgramControllerFindAll200Response
	
	export interface ProgramControllerFindAll200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Program[]
		headers?: undefined
	}
	
	export type ProgramControllerFindOneResponse =
		| ProgramControllerFindOne200Response
		| ProgramControllerFindOne404Response
	
	export interface ProgramControllerFindOne200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Program
		headers?: undefined
	}
	
	export interface ProgramControllerFindOne404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerGetRecommendationsResponse =
		| ProgramControllerGetRecommendations200Response
	
	export interface ProgramControllerGetRecommendations200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerGetStatsResponse =
		| ProgramControllerGetStats200Response
	
	export interface ProgramControllerGetStats200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerGetUserRolesParameters {
		/**
		 * @description <p>Program UUID</p>
		 * @type {string}
		 */
		id: string
		/**
		 * @description <p>User UUID</p>
		 * @type {string}
		 */
		userId: string
	}
	
	export type ProgramControllerGetUserRolesResponse =
		| ProgramControllerGetUserRoles200Response
	
	export interface ProgramControllerGetUserRoles200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerLinkToProductParameters {
		/**
		 * @description <p>Program UUID</p>
		 * @type {string}
		 */
		id: string
		/**
		 * @description <p>Product UUID</p>
		 * @type {string}
		 */
		productId: string
	}
	
	export type ProgramControllerLinkToProductResponse =
		| ProgramControllerLinkToProduct201Response
		| ProgramControllerLinkToProduct400Response
	
	export interface ProgramControllerLinkToProduct201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerLinkToProduct400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerRemoveResponse =
		| ProgramControllerRemove200Response
		| ProgramControllerRemove403Response
		| ProgramControllerRemove404Response
	
	export interface ProgramControllerRemove200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerRemove403Response {
		status: 403
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerRemove404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerRemoveRoleParameters {
		/**
		 * @description <p>Program UUID</p>
		 * @type {string}
		 */
		id: string
		/**
		 * @description <p>User UUID</p>
		 * @type {string}
		 */
		userId: string
		/**
		 * @description <p>Role name</p>
		 * @type {string}
		 */
		role: string
	}
	
	export type ProgramControllerRemoveRoleResponse =
		| ProgramControllerRemoveRole200Response
		| ProgramControllerRemoveRole403Response
	
	export interface ProgramControllerRemoveRole200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerRemoveRole403Response {
		status: 403
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerSearchParameters {
		/**
		 * @description <p>Search query</p>
		 * @type {string}
		 */
		query: string
		tags?: unknown
		isPublic?: unknown
		difficultyLevel?: unknown
	}
	
	export type ProgramControllerSearchResponse =
		| ProgramControllerSearch200Response
	
	export interface ProgramControllerSearch200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerUnenrollResponse =
		| ProgramControllerUnenroll200Response
		| ProgramControllerUnenroll404Response
	
	export interface ProgramControllerUnenroll200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerUnenroll404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerUnlinkFromProductParameters {
		/**
		 * @description <p>Program UUID</p>
		 * @type {string}
		 */
		id: string
		/**
		 * @description <p>Product UUID</p>
		 * @type {string}
		 */
		productId: string
	}
	
	export type ProgramControllerUnlinkFromProductResponse =
		| ProgramControllerUnlinkFromProduct200Response
		| ProgramControllerUnlinkFromProduct404Response
	
	export interface ProgramControllerUnlinkFromProduct200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerUnlinkFromProduct404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type ProgramControllerUpdateResponse =
		| ProgramControllerUpdate200Response
		| ProgramControllerUpdate403Response
		| ProgramControllerUpdate404Response
	
	export interface ProgramControllerUpdate200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Program
		headers?: undefined
	}
	
	export interface ProgramControllerUpdate403Response {
		status: 403
		body?: undefined
		headers?: undefined
	}
	
	export interface ProgramControllerUpdate404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * ProgramsApi - fetch parameter creator
 * @export
 */
export const ProgramsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Assign role to user in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {Api.AssignRoleDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerAssignRole(__params: ProgramsApi.ProgramControllerAssignRoleParameters, request: Api.AssignRoleDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerAssignRole.');
			}
			// verify required parameter 'userId' is not null or undefined
			if (__params.userId === null || __params.userId === undefined) {
				throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling programControllerAssignRole.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling programControllerAssignRole.');
			}

			let localVarPath = `/programs/{id}/users/{userId}/roles`
				.replace('{id}', encodeURIComponent(String(__params.id)))
				.replace('{userId}', encodeURIComponent(String(__params.userId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Check user access to program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerCheckAccess(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerCheckAccess.');
			}

			let localVarPath = `/programs/{id}/access-check`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Create a new program
		 * @param {Api.CreateProgramRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerCreate(request: Api.CreateProgramRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling programControllerCreate.');
			}

			let localVarPath = `/programs`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Enroll in a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {Api.EnrollmentRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerEnroll(id: string, request: Api.EnrollmentRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerEnroll.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling programControllerEnroll.');
			}

			let localVarPath = `/programs/{id}/enroll`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get all programs with optional filtering
		 * @param {unknown} [tags] <p>Filter by tags (comma-separated)</p>
		 * @param {unknown} [search] <p>Search in title and description</p>
		 * @param {unknown} [isActive] <p>Filter by active/inactive programs</p>
		 * @param {unknown} [isPublic] <p>Filter by public/private programs</p>
		 * @param {unknown} [difficultyLevel] <p>Filter by difficulty level</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerFindAll(__params: ProgramsApi.ProgramControllerFindAllParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/programs`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.tags !== undefined) {
				localVarQueryParameter.append('tags', String(__params.tags));
			}

			if (__params.search !== undefined) {
				localVarQueryParameter.append('search', String(__params.search));
			}

			if (__params.isActive !== undefined) {
				localVarQueryParameter.append('is_active', String(__params.isActive));
			}

			if (__params.isPublic !== undefined) {
				localVarQueryParameter.append('is_public', String(__params.isPublic));
			}

			if (__params.difficultyLevel !== undefined) {
				localVarQueryParameter.append('difficulty_level', String(__params.difficultyLevel));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get a program by ID
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerFindOne(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerFindOne.');
			}

			let localVarPath = `/programs/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get recommended programs for user
		 * @param {number} [limit] <p>Number of recommendations</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetRecommendations(limit: number | undefined, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/programs/recommendations/for-user`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get program statistics
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetStats(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerGetStats.');
			}

			let localVarPath = `/programs/{id}/stats`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get user roles in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetUserRoles(__params: ProgramsApi.ProgramControllerGetUserRolesParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerGetUserRoles.');
			}
			// verify required parameter 'userId' is not null or undefined
			if (__params.userId === null || __params.userId === undefined) {
				throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling programControllerGetUserRoles.');
			}

			let localVarPath = `/programs/{id}/users/{userId}/roles`
				.replace('{id}', encodeURIComponent(String(__params.id)))
				.replace('{userId}', encodeURIComponent(String(__params.userId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Link program to product
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} productId <p>Product UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerLinkToProduct(__params: ProgramsApi.ProgramControllerLinkToProductParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerLinkToProduct.');
			}
			// verify required parameter 'productId' is not null or undefined
			if (__params.productId === null || __params.productId === undefined) {
				throw new RequiredError('productId', 'Required parameter productId was null or undefined when calling programControllerLinkToProduct.');
			}

			let localVarPath = `/programs/{id}/products/{productId}`
				.replace('{id}', encodeURIComponent(String(__params.id)))
				.replace('{productId}', encodeURIComponent(String(__params.productId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete (deactivate) a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerRemove(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerRemove.');
			}

			let localVarPath = `/programs/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Remove role from user in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {string} role <p>Role name</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerRemoveRole(__params: ProgramsApi.ProgramControllerRemoveRoleParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerRemoveRole.');
			}
			// verify required parameter 'userId' is not null or undefined
			if (__params.userId === null || __params.userId === undefined) {
				throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling programControllerRemoveRole.');
			}
			// verify required parameter 'role' is not null or undefined
			if (__params.role === null || __params.role === undefined) {
				throw new RequiredError('role', 'Required parameter role was null or undefined when calling programControllerRemoveRole.');
			}

			let localVarPath = `/programs/{id}/users/{userId}/roles/{role}`
				.replace('{id}', encodeURIComponent(String(__params.id)))
				.replace('{userId}', encodeURIComponent(String(__params.userId)))
				.replace('{role}', encodeURIComponent(String(__params.role)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Search programs
		 * @param {string} query <p>Search query</p>
		 * @param {unknown} [tags]
		 * @param {unknown} [isPublic]
		 * @param {unknown} [difficultyLevel]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerSearch(__params: ProgramsApi.ProgramControllerSearchParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'query' is not null or undefined
			if (__params.query === null || __params.query === undefined) {
				throw new RequiredError('query', 'Required parameter query was null or undefined when calling programControllerSearch.');
			}

			let localVarPath = `/programs/search/{query}`
				.replace('{query}', encodeURIComponent(String(__params.query)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.tags !== undefined) {
				localVarQueryParameter.append('tags', String(__params.tags));
			}

			if (__params.isPublic !== undefined) {
				localVarQueryParameter.append('is_public', String(__params.isPublic));
			}

			if (__params.difficultyLevel !== undefined) {
				localVarQueryParameter.append('difficulty_level', String(__params.difficultyLevel));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Unenroll from a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUnenroll(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerUnenroll.');
			}

			let localVarPath = `/programs/{id}/enroll`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Unlink program from product
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} productId <p>Product UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUnlinkFromProduct(__params: ProgramsApi.ProgramControllerUnlinkFromProductParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerUnlinkFromProduct.');
			}
			// verify required parameter 'productId' is not null or undefined
			if (__params.productId === null || __params.productId === undefined) {
				throw new RequiredError('productId', 'Required parameter productId was null or undefined when calling programControllerUnlinkFromProduct.');
			}

			let localVarPath = `/programs/{id}/products/{productId}`
				.replace('{id}', encodeURIComponent(String(__params.id)))
				.replace('{productId}', encodeURIComponent(String(__params.productId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {Api.UpdateProgramRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUpdate(id: string, request: Api.UpdateProgramRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling programControllerUpdate.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling programControllerUpdate.');
			}

			let localVarPath = `/programs/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Assign role to user in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {Api.AssignRoleDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerAssignRole(__params: ProgramsApi.ProgramControllerAssignRoleParameters, request: Api.AssignRoleDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerAssignRoleResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerAssignRole(__params, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 403) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Check user access to program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerCheckAccess(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerCheckAccessResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerCheckAccess(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Create a new program
		 * @param {Api.CreateProgramRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerCreate(request: Api.CreateProgramRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerCreateResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerCreate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.Program,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 401) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Enroll in a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {Api.EnrollmentRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerEnroll(id: string, request: Api.EnrollmentRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerEnrollResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerEnroll(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get all programs with optional filtering
		 * @param {unknown} [tags] <p>Filter by tags (comma-separated)</p>
		 * @param {unknown} [search] <p>Search in title and description</p>
		 * @param {unknown} [isActive] <p>Filter by active/inactive programs</p>
		 * @param {unknown} [isPublic] <p>Filter by public/private programs</p>
		 * @param {unknown} [difficultyLevel] <p>Filter by difficulty level</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerFindAll(__params: ProgramsApi.ProgramControllerFindAllParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerFindAllResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerFindAll(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.Program[],
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Get a program by ID
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerFindOne(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerFindOneResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerFindOne(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.Program,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get recommended programs for user
		 * @param {number} [limit] <p>Number of recommendations</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetRecommendations(limit: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerGetRecommendationsResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerGetRecommendations(limit, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get program statistics
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetStats(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerGetStatsResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerGetStats(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get user roles in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerGetUserRoles(__params: ProgramsApi.ProgramControllerGetUserRolesParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerGetUserRolesResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerGetUserRoles(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Link program to product
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} productId <p>Product UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerLinkToProduct(__params: ProgramsApi.ProgramControllerLinkToProductParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerLinkToProductResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerLinkToProduct(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Delete (deactivate) a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerRemove(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerRemoveResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerRemove(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 403) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Remove role from user in program
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} userId <p>User UUID</p>
		 * @param {string} role <p>Role name</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerRemoveRole(__params: ProgramsApi.ProgramControllerRemoveRoleParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerRemoveRoleResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerRemoveRole(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 403) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Search programs
		 * @param {string} query <p>Search query</p>
		 * @param {unknown} [tags]
		 * @param {unknown} [isPublic]
		 * @param {unknown} [difficultyLevel]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerSearch(__params: ProgramsApi.ProgramControllerSearchParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerSearchResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerSearch(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Unenroll from a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUnenroll(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerUnenrollResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerUnenroll(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Unlink program from product
		 * @param {string} id <p>Program UUID</p>
		 * @param {string} productId <p>Product UUID</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUnlinkFromProduct(__params: ProgramsApi.ProgramControllerUnlinkFromProductParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerUnlinkFromProductResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerUnlinkFromProduct(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Update a program
		 * @param {string} id <p>Program UUID</p>
		 * @param {Api.UpdateProgramRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		programControllerUpdate(id: string, request: Api.UpdateProgramRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramsApi.ProgramControllerUpdateResponse> {
			const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).programControllerUpdate(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.Program,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory: FactoryFunction<ProgramsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProgramsApi(configuration, basePath, fetch);
};

/**
 * ProgramsApi - interface
 * @export
 * @interface ProgramsApi
 */
export interface ProgramsApiInterface {
	/**
	 * @summary Assign role to user in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {Api.AssignRoleDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerAssignRole(__params: ProgramsApi.ProgramControllerAssignRoleParameters, request: Api.AssignRoleDto, options?: RequestInit): Promise<ProgramsApi.ProgramControllerAssignRoleResponse>

	/**
	 * @summary Check user access to program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerCheckAccess(id: string, options?: RequestInit): Promise<ProgramsApi.ProgramControllerCheckAccessResponse>

	/**
	 * @summary Create a new program
	 * @param {Api.CreateProgramRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerCreate(request: Api.CreateProgramRequestDto, options?: RequestInit): Promise<ProgramsApi.ProgramControllerCreateResponse>

	/**
	 * @summary Enroll in a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {Api.EnrollmentRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerEnroll(id: string, request: Api.EnrollmentRequestDto, options?: RequestInit): Promise<ProgramsApi.ProgramControllerEnrollResponse>

	/**
	 * @summary Get all programs with optional filtering
	 * @param {unknown} [tags] <p>Filter by tags (comma-separated)</p>
	 * @param {unknown} [search] <p>Search in title and description</p>
	 * @param {unknown} [isActive] <p>Filter by active/inactive programs</p>
	 * @param {unknown} [isPublic] <p>Filter by public/private programs</p>
	 * @param {unknown} [difficultyLevel] <p>Filter by difficulty level</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerFindAll(__params: ProgramsApi.ProgramControllerFindAllParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerFindAllResponse>

	/**
	 * @summary Get a program by ID
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerFindOne(id: string, options?: RequestInit): Promise<ProgramsApi.ProgramControllerFindOneResponse>

	/**
	 * @summary Get recommended programs for user
	 * @param {number} [limit] <p>Number of recommendations</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerGetRecommendations(limit: number | undefined, options?: RequestInit): Promise<ProgramsApi.ProgramControllerGetRecommendationsResponse>

	/**
	 * @summary Get program statistics
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerGetStats(id: string, options?: RequestInit): Promise<ProgramsApi.ProgramControllerGetStatsResponse>

	/**
	 * @summary Get user roles in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerGetUserRoles(__params: ProgramsApi.ProgramControllerGetUserRolesParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerGetUserRolesResponse>

	/**
	 * @summary Link program to product
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} productId <p>Product UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerLinkToProduct(__params: ProgramsApi.ProgramControllerLinkToProductParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerLinkToProductResponse>

	/**
	 * @summary Delete (deactivate) a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerRemove(id: string, options?: RequestInit): Promise<ProgramsApi.ProgramControllerRemoveResponse>

	/**
	 * @summary Remove role from user in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {string} role <p>Role name</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerRemoveRole(__params: ProgramsApi.ProgramControllerRemoveRoleParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerRemoveRoleResponse>

	/**
	 * @summary Search programs
	 * @param {string} query <p>Search query</p>
	 * @param {unknown} [tags]
	 * @param {unknown} [isPublic]
	 * @param {unknown} [difficultyLevel]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerSearch(__params: ProgramsApi.ProgramControllerSearchParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerSearchResponse>

	/**
	 * @summary Unenroll from a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerUnenroll(id: string, options?: RequestInit): Promise<ProgramsApi.ProgramControllerUnenrollResponse>

	/**
	 * @summary Unlink program from product
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} productId <p>Product UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerUnlinkFromProduct(__params: ProgramsApi.ProgramControllerUnlinkFromProductParameters, options?: RequestInit): Promise<ProgramsApi.ProgramControllerUnlinkFromProductResponse>

	/**
	 * @summary Update a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {Api.UpdateProgramRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	programControllerUpdate(id: string, request: Api.UpdateProgramRequestDto, options?: RequestInit): Promise<ProgramsApi.ProgramControllerUpdateResponse>

}

/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI implements ProgramsApiInterface {
	/**
	 * @summary Assign role to user in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {Api.AssignRoleDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerAssignRole(__params: ProgramsApi.ProgramControllerAssignRoleParameters, request: Api.AssignRoleDto, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerAssignRole(__params, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Check user access to program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerCheckAccess(id: string, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerCheckAccess(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Create a new program
	 * @param {Api.CreateProgramRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerCreate(request: Api.CreateProgramRequestDto, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerCreate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Enroll in a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {Api.EnrollmentRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerEnroll(id: string, request: Api.EnrollmentRequestDto, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerEnroll(id, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get all programs with optional filtering
	 * @param {unknown} [tags] <p>Filter by tags (comma-separated)</p>
	 * @param {unknown} [search] <p>Search in title and description</p>
	 * @param {unknown} [isActive] <p>Filter by active/inactive programs</p>
	 * @param {unknown} [isPublic] <p>Filter by public/private programs</p>
	 * @param {unknown} [difficultyLevel] <p>Filter by difficulty level</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerFindAll(__params: ProgramsApi.ProgramControllerFindAllParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerFindAll(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get a program by ID
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerFindOne(id: string, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerFindOne(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get recommended programs for user
	 * @param {number} [limit] <p>Number of recommendations</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerGetRecommendations(limit: number | undefined, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerGetRecommendations(limit, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get program statistics
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerGetStats(id: string, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerGetStats(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get user roles in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerGetUserRoles(__params: ProgramsApi.ProgramControllerGetUserRolesParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerGetUserRoles(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Link program to product
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} productId <p>Product UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerLinkToProduct(__params: ProgramsApi.ProgramControllerLinkToProductParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerLinkToProduct(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete (deactivate) a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerRemove(id: string, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerRemove(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Remove role from user in program
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} userId <p>User UUID</p>
	 * @param {string} role <p>Role name</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerRemoveRole(__params: ProgramsApi.ProgramControllerRemoveRoleParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerRemoveRole(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Search programs
	 * @param {string} query <p>Search query</p>
	 * @param {unknown} [tags]
	 * @param {unknown} [isPublic]
	 * @param {unknown} [difficultyLevel]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerSearch(__params: ProgramsApi.ProgramControllerSearchParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerSearch(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Unenroll from a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerUnenroll(id: string, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerUnenroll(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Unlink program from product
	 * @param {string} id <p>Program UUID</p>
	 * @param {string} productId <p>Product UUID</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerUnlinkFromProduct(__params: ProgramsApi.ProgramControllerUnlinkFromProductParameters, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerUnlinkFromProduct(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a program
	 * @param {string} id <p>Program UUID</p>
	 * @param {Api.UpdateProgramRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public programControllerUpdate(id: string, request: Api.UpdateProgramRequestDto, options?: RequestInit) {
		return ProgramsApiFp(this.configuration).programControllerUpdate(id, request, options)(this.fetch, this.basePath);
	}

}
export namespace ProjectApi {
	export type ProjectControllerAddEditorResponse =
		| ProjectControllerAddEditor400Response
		| ProjectControllerAddEditor401Response
		| ProjectControllerAddEditor403Response
		| ProjectControllerAddEditor404Response
		| ProjectControllerAddEditor409Response
		| ProjectControllerAddEditor422Response
		| ProjectControllerAddEditor500Response
	
	export interface ProjectControllerAddEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerCreateOneResponse =
		| ProjectControllerCreateOne400Response
		| ProjectControllerCreateOne401Response
		| ProjectControllerCreateOne403Response
		| ProjectControllerCreateOne404Response
		| ProjectControllerCreateOne409Response
		| ProjectControllerCreateOne422Response
		| ProjectControllerCreateOne500Response
		| ProjectControllerCreateOneDefaultResponse
	
	export interface ProjectControllerCreateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerCreateOneDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
	export type ProjectControllerDeleteOneBaseResponse =
		| ProjectControllerDeleteOneBase400Response
		| ProjectControllerDeleteOneBase401Response
		| ProjectControllerDeleteOneBase403Response
		| ProjectControllerDeleteOneBase404Response
		| ProjectControllerDeleteOneBase409Response
		| ProjectControllerDeleteOneBase422Response
		| ProjectControllerDeleteOneBase500Response
	
	export interface ProjectControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerGetManyResponse =
		| ProjectControllerGetMany400Response
		| ProjectControllerGetMany401Response
		| ProjectControllerGetMany403Response
		| ProjectControllerGetMany404Response
		| ProjectControllerGetMany409Response
		| ProjectControllerGetMany422Response
		| ProjectControllerGetMany500Response
	
	export interface ProjectControllerGetMany400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetMany500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerGetOneResponse =
		| ProjectControllerGetOne400Response
		| ProjectControllerGetOne401Response
		| ProjectControllerGetOne403Response
		| ProjectControllerGetOne404Response
		| ProjectControllerGetOne409Response
		| ProjectControllerGetOne422Response
		| ProjectControllerGetOne500Response
		| ProjectControllerGetOneDefaultResponse
	
	export interface ProjectControllerGetOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerGetOneDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
	export type ProjectControllerICanEditResponse =
		| ProjectControllerICanEdit200Response
		| ProjectControllerICanEdit400Response
		| ProjectControllerICanEdit401Response
		| ProjectControllerICanEdit403Response
		| ProjectControllerICanEdit404Response
		| ProjectControllerICanEdit409Response
		| ProjectControllerICanEdit422Response
		| ProjectControllerICanEdit500Response
	
	export interface ProjectControllerICanEdit200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerICanEdit500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerOwnedByMeResponse =
		| ProjectControllerOwnedByMe200Response
		| ProjectControllerOwnedByMe400Response
		| ProjectControllerOwnedByMe401Response
		| ProjectControllerOwnedByMe403Response
		| ProjectControllerOwnedByMe404Response
		| ProjectControllerOwnedByMe409Response
		| ProjectControllerOwnedByMe422Response
		| ProjectControllerOwnedByMe500Response
	
	export interface ProjectControllerOwnedByMe200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerOwnedByMe500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerRemoveEditorResponse =
		| ProjectControllerRemoveEditor400Response
		| ProjectControllerRemoveEditor401Response
		| ProjectControllerRemoveEditor403Response
		| ProjectControllerRemoveEditor404Response
		| ProjectControllerRemoveEditor409Response
		| ProjectControllerRemoveEditor422Response
		| ProjectControllerRemoveEditor500Response
	
	export interface ProjectControllerRemoveEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerSwitchOwnerResponse =
		| ProjectControllerSwitchOwner400Response
		| ProjectControllerSwitchOwner401Response
		| ProjectControllerSwitchOwner403Response
		| ProjectControllerSwitchOwner404Response
		| ProjectControllerSwitchOwner409Response
		| ProjectControllerSwitchOwner422Response
		| ProjectControllerSwitchOwner500Response
	
	export interface ProjectControllerSwitchOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerUpdateOneResponse =
		| ProjectControllerUpdateOne400Response
		| ProjectControllerUpdateOne401Response
		| ProjectControllerUpdateOne403Response
		| ProjectControllerUpdateOne404Response
		| ProjectControllerUpdateOne409Response
		| ProjectControllerUpdateOne422Response
		| ProjectControllerUpdateOne500Response
		| ProjectControllerUpdateOneDefaultResponse
	
	export interface ProjectControllerUpdateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerUpdateOneDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerAddEditor.');
			}

			let localVarPath = `/project/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CreateProjectDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerCreateOne(request: Api.CreateProjectDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerCreateOne.');
			}

			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project/{slug}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerGetMany(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerGetOne(slug: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'slug' is not null or undefined
			if (slug === null || slug === undefined) {
				throw new RequiredError('slug', 'Required parameter slug was null or undefined when calling projectControllerGetOne.');
			}

			let localVarPath = `/project/{slug}`
				.replace('{slug}', encodeURIComponent(String(slug)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerICanEdit(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project/get-editable-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerOwnedByMe(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project/get-owned-by-me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerRemoveEditor.');
			}

			let localVarPath = `/project/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerSwitchOwner.');
			}

			let localVarPath = `/project/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CreateProjectDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerUpdateOne(request: Api.CreateProjectDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerUpdateOne.');
			}

			let localVarPath = `/project/{slug}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerAddEditorResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerAddEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CreateProjectDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerCreateOne(request: Api.CreateProjectDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerCreateOneResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerCreateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ProjectEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerGetMany(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerGetManyResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerGetMany(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} slug
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerGetOne(slug: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerGetOneResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerGetOne(slug, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ProjectEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users has permission to edit.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerICanEdit(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerICanEditResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerICanEdit(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Obtains all items the current users owns.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerOwnedByMe(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerOwnedByMeResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerOwnedByMe(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerRemoveEditorResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerRemoveEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerSwitchOwnerResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerSwitchOwner(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CreateProjectDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerUpdateOne(request: Api.CreateProjectDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerUpdateOneResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerUpdateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ProjectEntity,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory: FactoryFunction<ProjectApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectApi(configuration, basePath, fetch);
};

/**
 * ProjectApi - interface
 * @export
 * @interface ProjectApi
 */
export interface ProjectApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerAddEditorResponse>

	/**
	 * @param {Api.CreateProjectDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerCreateOne(request: Api.CreateProjectDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerCreateOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerDeleteOneBase(options?: RequestInit): Promise<ProjectApi.ProjectControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerGetMany(options?: RequestInit): Promise<ProjectApi.ProjectControllerGetManyResponse>

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerGetOne(slug: string, options?: RequestInit): Promise<ProjectApi.ProjectControllerGetOneResponse>

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerICanEdit(options?: RequestInit): Promise<ProjectApi.ProjectControllerICanEditResponse>

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerOwnedByMe(options?: RequestInit): Promise<ProjectApi.ProjectControllerOwnedByMeResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerRemoveEditorResponse>

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerSwitchOwnerResponse>

	/**
	 * @param {Api.CreateProjectDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerUpdateOne(request: Api.CreateProjectDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerUpdateOneResponse>

}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI implements ProjectApiInterface {
	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CreateProjectDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerCreateOne(request: Api.CreateProjectDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerCreateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerDeleteOneBase(options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerGetMany(options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerGetMany(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} slug
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerGetOne(slug: string, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerGetOne(slug, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users has permission to edit.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerICanEdit(options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerICanEdit(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Obtains all items the current users owns.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerOwnedByMe(options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerOwnedByMe(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CreateProjectDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerUpdateOne(request: Api.CreateProjectDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerUpdateOne(request, options)(this.fetch, this.basePath);
	}

}
export namespace ProjectVersionApi {
	export type ProjectVersionControllerCreateOneResponse =
		| ProjectVersionControllerCreateOne400Response
		| ProjectVersionControllerCreateOne401Response
		| ProjectVersionControllerCreateOne403Response
		| ProjectVersionControllerCreateOne404Response
		| ProjectVersionControllerCreateOne409Response
		| ProjectVersionControllerCreateOne422Response
		| ProjectVersionControllerCreateOne500Response
	
	export interface ProjectVersionControllerCreateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerCreateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectVersionControllerDeleteOneResponse =
		| ProjectVersionControllerDeleteOne400Response
		| ProjectVersionControllerDeleteOne401Response
		| ProjectVersionControllerDeleteOne403Response
		| ProjectVersionControllerDeleteOne404Response
		| ProjectVersionControllerDeleteOne409Response
		| ProjectVersionControllerDeleteOne422Response
		| ProjectVersionControllerDeleteOne500Response
	
	export interface ProjectVersionControllerDeleteOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerDeleteOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectVersionControllerGetManyBaseResponse =
		| ProjectVersionControllerGetManyBase400Response
		| ProjectVersionControllerGetManyBase401Response
		| ProjectVersionControllerGetManyBase403Response
		| ProjectVersionControllerGetManyBase404Response
		| ProjectVersionControllerGetManyBase409Response
		| ProjectVersionControllerGetManyBase422Response
		| ProjectVersionControllerGetManyBase500Response
	
	export interface ProjectVersionControllerGetManyBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetManyBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectVersionControllerGetOneBaseResponse =
		| ProjectVersionControllerGetOneBase400Response
		| ProjectVersionControllerGetOneBase401Response
		| ProjectVersionControllerGetOneBase403Response
		| ProjectVersionControllerGetOneBase404Response
		| ProjectVersionControllerGetOneBase409Response
		| ProjectVersionControllerGetOneBase422Response
		| ProjectVersionControllerGetOneBase500Response
	
	export interface ProjectVersionControllerGetOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectVersionControllerGetOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * ProjectVersionApi - fetch parameter creator
 * @export
 */
export const ProjectVersionApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerCreateOne(request: Api.ProjectVersionEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectVersionControllerCreateOne.');
			}

			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerDeleteOne(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project-version/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project-version/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectVersionApi - functional programming interface
 * @export
 */
export const ProjectVersionApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerCreateOne(request: Api.ProjectVersionEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.ProjectVersionControllerCreateOneResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).projectVersionControllerCreateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerDeleteOne(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.ProjectVersionControllerDeleteOneResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).projectVersionControllerDeleteOne(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.ProjectVersionControllerGetManyBaseResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).projectVersionControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectVersionControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.ProjectVersionControllerGetOneBaseResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).projectVersionControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * ProjectVersionApi - factory interface
 * @export
 */
export const ProjectVersionApiFactory: FactoryFunction<ProjectVersionApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectVersionApi(configuration, basePath, fetch);
};

/**
 * ProjectVersionApi - interface
 * @export
 * @interface ProjectVersionApi
 */
export interface ProjectVersionApiInterface {
	/**
	 * @param {Api.ProjectVersionEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectVersionControllerCreateOne(request: Api.ProjectVersionEntity, options?: RequestInit): Promise<ProjectVersionApi.ProjectVersionControllerCreateOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectVersionControllerDeleteOne(options?: RequestInit): Promise<ProjectVersionApi.ProjectVersionControllerDeleteOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectVersionControllerGetManyBase(options?: RequestInit): Promise<ProjectVersionApi.ProjectVersionControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectVersionControllerGetOneBase(options?: RequestInit): Promise<ProjectVersionApi.ProjectVersionControllerGetOneBaseResponse>

}

/**
 * ProjectVersionApi - object-oriented interface
 * @export
 * @class ProjectVersionApi
 * @extends {BaseAPI}
 */
export class ProjectVersionApi extends BaseAPI implements ProjectVersionApiInterface {
	/**
	 * @param {Api.ProjectVersionEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectVersionControllerCreateOne(request: Api.ProjectVersionEntity, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).projectVersionControllerCreateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectVersionControllerDeleteOne(options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).projectVersionControllerDeleteOne(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectVersionControllerGetManyBase(options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).projectVersionControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectVersionControllerGetOneBase(options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).projectVersionControllerGetOneBase(options)(this.fetch, this.basePath);
	}

}
export namespace QuizApi {
	export type QuizControllerCreateManyBaseResponse =
		| QuizControllerCreateManyBase201Response
	
	export interface QuizControllerCreateManyBase201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerCreateOneBaseResponse =
		| QuizControllerCreateOneBase201Response
	
	export interface QuizControllerCreateOneBase201Response {
		status: 201
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerDeleteOneBaseResponse =
		| QuizControllerDeleteOneBase200Response
	
	export interface QuizControllerDeleteOneBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerGetManyBaseResponse =
		| QuizControllerGetManyBase200Response
	
	export interface QuizControllerGetManyBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerGetOneBaseResponse =
		| QuizControllerGetOneBase200Response
	
	export interface QuizControllerGetOneBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerReplaceOneBaseResponse =
		| QuizControllerReplaceOneBase200Response
	
	export interface QuizControllerReplaceOneBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type QuizControllerUpdateOneBaseResponse =
		| QuizControllerUpdateOneBase200Response
	
	export interface QuizControllerUpdateOneBase200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * QuizApi - fetch parameter creator
 * @export
 */
export const QuizApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.CreateManyQuizEntityDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerCreateManyBase(request: Api.CreateManyQuizEntityDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling quizControllerCreateManyBase.');
			}

			let localVarPath = `/courses/{courseid}/quiz/bulk`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerCreateOneBase(request: Api.QuizEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling quizControllerCreateOneBase.');
			}

			let localVarPath = `/courses/{courseid}/quiz`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/{courseid}/quiz/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerGetManyBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/{courseid}/quiz`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerGetOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/courses/{courseid}/quiz/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerReplaceOneBase(request: Api.QuizEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling quizControllerReplaceOneBase.');
			}

			let localVarPath = `/courses/{courseid}/quiz/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerUpdateOneBase(request: Api.QuizEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling quizControllerUpdateOneBase.');
			}

			let localVarPath = `/courses/{courseid}/quiz/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * QuizApi - functional programming interface
 * @export
 */
export const QuizApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.CreateManyQuizEntityDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerCreateManyBase(request: Api.CreateManyQuizEntityDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerCreateManyBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerCreateManyBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerCreateOneBase(request: Api.QuizEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerCreateOneBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerCreateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerGetManyBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerGetManyBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerGetManyBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerGetOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerGetOneBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerGetOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerReplaceOneBase(request: Api.QuizEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerReplaceOneBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerReplaceOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.QuizEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		quizControllerUpdateOneBase(request: Api.QuizEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<QuizApi.QuizControllerUpdateOneBaseResponse> {
			const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizControllerUpdateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * QuizApi - factory interface
 * @export
 */
export const QuizApiFactory: FactoryFunction<QuizApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new QuizApi(configuration, basePath, fetch);
};

/**
 * QuizApi - interface
 * @export
 * @interface QuizApi
 */
export interface QuizApiInterface {
	/**
	 * @param {Api.CreateManyQuizEntityDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerCreateManyBase(request: Api.CreateManyQuizEntityDto, options?: RequestInit): Promise<QuizApi.QuizControllerCreateManyBaseResponse>

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerCreateOneBase(request: Api.QuizEntity, options?: RequestInit): Promise<QuizApi.QuizControllerCreateOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerDeleteOneBase(options?: RequestInit): Promise<QuizApi.QuizControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerGetManyBase(options?: RequestInit): Promise<QuizApi.QuizControllerGetManyBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerGetOneBase(options?: RequestInit): Promise<QuizApi.QuizControllerGetOneBaseResponse>

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerReplaceOneBase(request: Api.QuizEntity, options?: RequestInit): Promise<QuizApi.QuizControllerReplaceOneBaseResponse>

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	quizControllerUpdateOneBase(request: Api.QuizEntity, options?: RequestInit): Promise<QuizApi.QuizControllerUpdateOneBaseResponse>

}

/**
 * QuizApi - object-oriented interface
 * @export
 * @class QuizApi
 * @extends {BaseAPI}
 */
export class QuizApi extends BaseAPI implements QuizApiInterface {
	/**
	 * @param {Api.CreateManyQuizEntityDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerCreateManyBase(request: Api.CreateManyQuizEntityDto, options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerCreateManyBase(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerCreateOneBase(request: Api.QuizEntity, options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerCreateOneBase(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerDeleteOneBase(options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerGetManyBase(options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerGetManyBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerGetOneBase(options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerGetOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerReplaceOneBase(request: Api.QuizEntity, options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerReplaceOneBase(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.QuizEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public quizControllerUpdateOneBase(request: Api.QuizEntity, options?: RequestInit) {
		return QuizApiFp(this.configuration).quizControllerUpdateOneBase(request, options)(this.fetch, this.basePath);
	}

}
export namespace TicketApi {
	export type TicketControllerCreateOneResponse =
		| TicketControllerCreateOne400Response
		| TicketControllerCreateOne401Response
		| TicketControllerCreateOne403Response
		| TicketControllerCreateOne404Response
		| TicketControllerCreateOne409Response
		| TicketControllerCreateOne422Response
		| TicketControllerCreateOne500Response
	
	export interface TicketControllerCreateOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerCreateOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type TicketControllerDeleteOneBaseResponse =
		| TicketControllerDeleteOneBase400Response
		| TicketControllerDeleteOneBase401Response
		| TicketControllerDeleteOneBase403Response
		| TicketControllerDeleteOneBase404Response
		| TicketControllerDeleteOneBase409Response
		| TicketControllerDeleteOneBase422Response
		| TicketControllerDeleteOneBase500Response
	
	export interface TicketControllerDeleteOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerDeleteOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type TicketControllerGetManyResponse =
		| TicketControllerGetMany400Response
		| TicketControllerGetMany401Response
		| TicketControllerGetMany403Response
		| TicketControllerGetMany404Response
		| TicketControllerGetMany409Response
		| TicketControllerGetMany422Response
		| TicketControllerGetMany500Response
	
	export interface TicketControllerGetMany400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetMany500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type TicketControllerGetOneResponse =
		| TicketControllerGetOne400Response
		| TicketControllerGetOne401Response
		| TicketControllerGetOne403Response
		| TicketControllerGetOne404Response
		| TicketControllerGetOne409Response
		| TicketControllerGetOne422Response
		| TicketControllerGetOne500Response
	
	export interface TicketControllerGetOne400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerGetOne500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type TicketControllerUpdateOneBaseResponse =
		| TicketControllerUpdateOneBase400Response
		| TicketControllerUpdateOneBase401Response
		| TicketControllerUpdateOneBase403Response
		| TicketControllerUpdateOneBase404Response
		| TicketControllerUpdateOneBase409Response
		| TicketControllerUpdateOneBase422Response
		| TicketControllerUpdateOneBase500Response
	
	export interface TicketControllerUpdateOneBase400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface TicketControllerUpdateOneBase500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * TicketApi - fetch parameter creator
 * @export
 */
export const TicketApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.CreateTicketDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerCreateOne(request: Api.CreateTicketDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling ticketControllerCreateOne.');
			}

			let localVarPath = `/tickets`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerDeleteOneBase(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/tickets/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerGetMany(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/tickets`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerGetOne(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling ticketControllerGetOne.');
			}

			let localVarPath = `/tickets/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TicketEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerUpdateOneBase(request: Api.TicketEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling ticketControllerUpdateOneBase.');
			}

			let localVarPath = `/tickets/{id}`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * TicketApi - functional programming interface
 * @export
 */
export const TicketApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.CreateTicketDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerCreateOne(request: Api.CreateTicketDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TicketApi.TicketControllerCreateOneResponse> {
			const localVarFetchArgs = TicketApiFetchParamCreator(configuration).ticketControllerCreateOne(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerDeleteOneBase(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TicketApi.TicketControllerDeleteOneBaseResponse> {
			const localVarFetchArgs = TicketApiFetchParamCreator(configuration).ticketControllerDeleteOneBase(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerGetMany(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TicketApi.TicketControllerGetManyResponse> {
			const localVarFetchArgs = TicketApiFetchParamCreator(configuration).ticketControllerGetMany(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerGetOne(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TicketApi.TicketControllerGetOneResponse> {
			const localVarFetchArgs = TicketApiFetchParamCreator(configuration).ticketControllerGetOne(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TicketEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		ticketControllerUpdateOneBase(request: Api.TicketEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TicketApi.TicketControllerUpdateOneBaseResponse> {
			const localVarFetchArgs = TicketApiFetchParamCreator(configuration).ticketControllerUpdateOneBase(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * TicketApi - factory interface
 * @export
 */
export const TicketApiFactory: FactoryFunction<TicketApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new TicketApi(configuration, basePath, fetch);
};

/**
 * TicketApi - interface
 * @export
 * @interface TicketApi
 */
export interface TicketApiInterface {
	/**
	 * @param {Api.CreateTicketDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	ticketControllerCreateOne(request: Api.CreateTicketDto, options?: RequestInit): Promise<TicketApi.TicketControllerCreateOneResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	ticketControllerDeleteOneBase(options?: RequestInit): Promise<TicketApi.TicketControllerDeleteOneBaseResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	ticketControllerGetMany(options?: RequestInit): Promise<TicketApi.TicketControllerGetManyResponse>

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	ticketControllerGetOne(id: string, options?: RequestInit): Promise<TicketApi.TicketControllerGetOneResponse>

	/**
	 * @param {Api.TicketEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	ticketControllerUpdateOneBase(request: Api.TicketEntity, options?: RequestInit): Promise<TicketApi.TicketControllerUpdateOneBaseResponse>

}

/**
 * TicketApi - object-oriented interface
 * @export
 * @class TicketApi
 * @extends {BaseAPI}
 */
export class TicketApi extends BaseAPI implements TicketApiInterface {
	/**
	 * @param {Api.CreateTicketDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public ticketControllerCreateOne(request: Api.CreateTicketDto, options?: RequestInit) {
		return TicketApiFp(this.configuration).ticketControllerCreateOne(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public ticketControllerDeleteOneBase(options?: RequestInit) {
		return TicketApiFp(this.configuration).ticketControllerDeleteOneBase(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public ticketControllerGetMany(options?: RequestInit) {
		return TicketApiFp(this.configuration).ticketControllerGetMany(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public ticketControllerGetOne(id: string, options?: RequestInit) {
		return TicketApiFp(this.configuration).ticketControllerGetOne(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TicketEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public ticketControllerUpdateOneBase(request: Api.TicketEntity, options?: RequestInit) {
		return TicketApiFp(this.configuration).ticketControllerUpdateOneBase(request, options)(this.fetch, this.basePath);
	}

}
export namespace UsersApi {
	export type UserControllerMeResponse =
		| UserControllerMe400Response
		| UserControllerMe401Response
		| UserControllerMe403Response
		| UserControllerMe404Response
		| UserControllerMe409Response
		| UserControllerMe422Response
		| UserControllerMe500Response
		| UserControllerMeDefaultResponse
	
	export interface UserControllerMe400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMe500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserControllerMeDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserEntity
		headers?: undefined
	}
	
	export type UserProfileControllerGetResponse =
		| UserProfileControllerGet400Response
		| UserProfileControllerGet401Response
		| UserProfileControllerGet403Response
		| UserProfileControllerGet404Response
		| UserProfileControllerGet409Response
		| UserProfileControllerGet422Response
		| UserProfileControllerGet500Response
		| UserProfileControllerGetDefaultResponse
	
	export interface UserProfileControllerGet400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGet500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerGetDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserProfileEntity
		headers?: undefined
	}
	
	export type UserProfileControllerUpdateResponse =
		| UserProfileControllerUpdate400Response
		| UserProfileControllerUpdate401Response
		| UserProfileControllerUpdate403Response
		| UserProfileControllerUpdate404Response
		| UserProfileControllerUpdate409Response
		| UserProfileControllerUpdate422Response
		| UserProfileControllerUpdate500Response
		| UserProfileControllerUpdateDefaultResponse
	
	export interface UserProfileControllerUpdate400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdate500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserProfileEntity
		headers?: undefined
	}
	
	export type UserProfileControllerUpdateProfilePictureResponse =
		| UserProfileControllerUpdateProfilePicture400Response
		| UserProfileControllerUpdateProfilePicture401Response
		| UserProfileControllerUpdateProfilePicture403Response
		| UserProfileControllerUpdateProfilePicture404Response
		| UserProfileControllerUpdateProfilePicture409Response
		| UserProfileControllerUpdateProfilePicture422Response
		| UserProfileControllerUpdateProfilePicture500Response
		| UserProfileControllerUpdateProfilePictureDefaultResponse
	
	export interface UserProfileControllerUpdateProfilePicture400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePicture500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UserProfileControllerUpdateProfilePictureDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserProfileEntity
		headers?: undefined
	}
	
}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerMe(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/users/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerGet(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/user-profile/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.UpdateUserProfileDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerUpdate(request: Api.UpdateUserProfileDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling userProfileControllerUpdate.');
			}

			let localVarPath = `/user-profile/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerUpdateProfilePicture(request: Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData | undefined, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/user-profile/profile-picture`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			// localVarHeaderParameter.set('Content-Type', 'multipart/form-data'); // Commented out to let browser set boundary

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				const localVarFormData = new FormData();
				if (request.profilePicture !== undefined) {
					localVarFormData.append('profilePicture', request.profilePicture.value);
				}
				localVarRequestOptions.body = localVarFormData;
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerMe(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UsersApi.UserControllerMeResponse> {
			const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userControllerMe(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerGet(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UsersApi.UserProfileControllerGetResponse> {
			const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userProfileControllerGet(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserProfileEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.UpdateUserProfileDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerUpdate(request: Api.UpdateUserProfileDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UsersApi.UserProfileControllerUpdateResponse> {
			const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userProfileControllerUpdate(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserProfileEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userProfileControllerUpdateProfilePicture(request: Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UsersApi.UserProfileControllerUpdateProfilePictureResponse> {
			const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userProfileControllerUpdateProfilePicture(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserProfileEntity,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory: FactoryFunction<UsersApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new UsersApi(configuration, basePath, fetch);
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	userControllerMe(options?: RequestInit): Promise<UsersApi.UserControllerMeResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	userProfileControllerGet(options?: RequestInit): Promise<UsersApi.UserProfileControllerGetResponse>

	/**
	 * @param {Api.UpdateUserProfileDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	userProfileControllerUpdate(request: Api.UpdateUserProfileDto, options?: RequestInit): Promise<UsersApi.UserProfileControllerUpdateResponse>

	/**
	 * @param {Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	userProfileControllerUpdateProfilePicture(request: Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData | undefined, options?: RequestInit): Promise<UsersApi.UserProfileControllerUpdateProfilePictureResponse>

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public userControllerMe(options?: RequestInit) {
		return UsersApiFp(this.configuration).userControllerMe(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public userProfileControllerGet(options?: RequestInit) {
		return UsersApiFp(this.configuration).userProfileControllerGet(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.UpdateUserProfileDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public userProfileControllerUpdate(request: Api.UpdateUserProfileDto, options?: RequestInit) {
		return UsersApiFp(this.configuration).userProfileControllerUpdate(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public userProfileControllerUpdateProfilePicture(request: Api.UserProfileControllerUpdateProfilePictureRequest.MultipartFormData | undefined, options?: RequestInit) {
		return UsersApiFp(this.configuration).userProfileControllerUpdateProfilePicture(request, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
