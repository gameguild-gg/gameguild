/* eslint-disable */
// tslint:disable
/**
 * gameguild.gg
 * 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

export namespace AuthApi {
	export type AuthControllerGetCurrentUserResponse =
		| AuthControllerGetCurrentUser400Response
		| AuthControllerGetCurrentUser401Response
		| AuthControllerGetCurrentUser403Response
		| AuthControllerGetCurrentUser404Response
		| AuthControllerGetCurrentUser409Response
		| AuthControllerGetCurrentUser422Response
		| AuthControllerGetCurrentUser500Response
		| AuthControllerGetCurrentUserDefaultResponse
	
	export interface AuthControllerGetCurrentUser400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUser500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerGetCurrentUserDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.UserEntity
		headers?: undefined
	}
	
	export type AuthControllerGetWeb3SignInChallengeResponse =
		| AuthControllerGetWeb3SignInChallengeDefaultResponse
	
	export interface AuthControllerGetWeb3SignInChallengeDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.EthereumSigninChallengeResponseDto
		headers?: undefined
	}
	
	export type AuthControllerLocalSignWithEmailOrUsernameResponse =
		| AuthControllerLocalSignWithEmailOrUsernameDefaultResponse
	
	export interface AuthControllerLocalSignWithEmailOrUsernameDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerMagicLinkResponse =
		| AuthControllerMagicLinkDefaultResponse
	
	export interface AuthControllerMagicLinkDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.OkDto
		headers?: undefined
	}
	
	export type AuthControllerRefreshTokenResponse =
		| AuthControllerRefreshToken400Response
		| AuthControllerRefreshToken401Response
		| AuthControllerRefreshToken403Response
		| AuthControllerRefreshToken404Response
		| AuthControllerRefreshToken409Response
		| AuthControllerRefreshToken422Response
		| AuthControllerRefreshToken500Response
		| AuthControllerRefreshTokenDefaultResponse
	
	export interface AuthControllerRefreshToken400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshToken500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface AuthControllerRefreshTokenDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerSignInWithGoogleResponse =
		| AuthControllerSignInWithGoogleDefaultResponse
	
	export interface AuthControllerSignInWithGoogleDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerSignUpWithEmailUsernamePasswordResponse =
		| AuthControllerSignUpWithEmailUsernamePasswordDefaultResponse
	
	export interface AuthControllerSignUpWithEmailUsernamePasswordDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
	export type AuthControllerUserExistsResponse =
		| AuthControllerUserExistsDefaultResponse
	
	export interface AuthControllerUserExistsDefaultResponse {
		status: number
		contentType: 'application/json'
		body: boolean
		headers?: undefined
	}
	
	export type AuthControllerValidateWeb3SignInChallengeResponse =
		| AuthControllerValidateWeb3SignInChallengeDefaultResponse
	
	export interface AuthControllerValidateWeb3SignInChallengeDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.LocalSignInResponseDto
		headers?: undefined
	}
	
}

/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/auth/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerGetWeb3SignInChallenge.');
			}

			let localVarPath = `/auth/web3/sign-in/challenge`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.LocalSignInDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerLocalSignWithEmailOrUsername.');
			}

			let localVarPath = `/auth/local/sign-in`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerMagicLink.');
			}

			let localVarPath = `/auth/magic-link`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/auth/refresh-token`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'token' is not null or undefined
			if (token === null || token === undefined) {
				throw new RequiredError('token', 'Required parameter token was null or undefined when calling authControllerSignInWithGoogle.');
			}

			let localVarPath = `/auth/google/callback/{token}`
				.replace('{token}', encodeURIComponent(String(token)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerSignUpWithEmailUsernamePassword.');
			}

			let localVarPath = `/auth/local/sign-up`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'user' is not null or undefined
			if (user === null || user === undefined) {
				throw new RequiredError('user', 'Required parameter user was null or undefined when calling authControllerUserExists.');
			}

			let localVarPath = `/auth/userExists/{user}`
				.replace('{user}', encodeURIComponent(String(user)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerValidateWeb3SignInChallenge.');
			}

			let localVarPath = `/auth/web3/sign-in/validate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerGetCurrentUserResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetCurrentUser(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.UserEntity,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerGetWeb3SignInChallengeResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetWeb3SignInChallenge(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.EthereumSigninChallengeResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.LocalSignInDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerLocalSignWithEmailOrUsernameResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerLocalSignWithEmailOrUsername(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerMagicLinkResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerMagicLink(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.OkDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerRefreshTokenResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerRefreshToken(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerSignInWithGoogleResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignInWithGoogle(token, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerSignUpWithEmailUsernamePasswordResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignUpWithEmailUsernamePassword(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerUserExistsResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerUserExists(user, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as boolean,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AuthApi.AuthControllerValidateWeb3SignInChallengeResponse> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerValidateWeb3SignInChallenge(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.LocalSignInResponseDto,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory: FactoryFunction<AuthApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new AuthApi(configuration, basePath, fetch);
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerGetCurrentUser(options?: RequestInit): Promise<AuthApi.AuthControllerGetCurrentUserResponse>

	/**
	 * @param {Api.EthereumSigninChallengeRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit): Promise<AuthApi.AuthControllerGetWeb3SignInChallengeResponse>

	/**
	 * @param {Api.LocalSignInDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options?: RequestInit): Promise<AuthApi.AuthControllerLocalSignWithEmailOrUsernameResponse>

	/**
	 * @param {Api.EmailDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerMagicLink(request: Api.EmailDto, options?: RequestInit): Promise<AuthApi.AuthControllerMagicLinkResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerRefreshToken(options?: RequestInit): Promise<AuthApi.AuthControllerRefreshTokenResponse>

	/**
	 * @param {string} token
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerSignInWithGoogle(token: string, options?: RequestInit): Promise<AuthApi.AuthControllerSignInWithGoogleResponse>

	/**
	 * @param {Api.LocalSignUpDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit): Promise<AuthApi.AuthControllerSignUpWithEmailUsernamePasswordResponse>

	/**
	 * @param {string} user
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerUserExists(user: string, options?: RequestInit): Promise<AuthApi.AuthControllerUserExistsResponse>

	/**
	 * @param {Api.EthereumSigninValidateRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit): Promise<AuthApi.AuthControllerValidateWeb3SignInChallengeResponse>

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetCurrentUser(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetCurrentUser(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninChallengeRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.LocalSignInDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerLocalSignWithEmailOrUsername(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EmailDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerMagicLink(request: Api.EmailDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerMagicLink(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerRefreshToken(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerRefreshToken(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} token
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignInWithGoogle(token: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignInWithGoogle(token, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.LocalSignUpDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignUpWithEmailUsernamePassword(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} user
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerUserExists(user: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerUserExists(user, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninValidateRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerValidateWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

}
export namespace CompetitionsApi {
	export type CompetitionControllerFindChessMatchResultResponse =
		| CompetitionControllerFindChessMatchResult400Response
		| CompetitionControllerFindChessMatchResult401Response
		| CompetitionControllerFindChessMatchResult403Response
		| CompetitionControllerFindChessMatchResult404Response
		| CompetitionControllerFindChessMatchResult409Response
		| CompetitionControllerFindChessMatchResult422Response
		| CompetitionControllerFindChessMatchResult500Response
		| CompetitionControllerFindChessMatchResultDefaultResponse
	
	export interface CompetitionControllerFindChessMatchResult400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResult500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerFindChessMatchResultDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.MatchSearchResponseDto[]
		headers?: undefined
	}
	
	export type CompetitionControllerGetChessLeaderboardResponse =
		| CompetitionControllerGetChessLeaderboard400Response
		| CompetitionControllerGetChessLeaderboard401Response
		| CompetitionControllerGetChessLeaderboard403Response
		| CompetitionControllerGetChessLeaderboard404Response
		| CompetitionControllerGetChessLeaderboard409Response
		| CompetitionControllerGetChessLeaderboard422Response
		| CompetitionControllerGetChessLeaderboard500Response
		| CompetitionControllerGetChessLeaderboardDefaultResponse
	
	export interface CompetitionControllerGetChessLeaderboard400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboard500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessLeaderboardDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessLeaderboardResponseEntryDto[]
		headers?: undefined
	}
	
	export type CompetitionControllerGetChessMatchResultResponse =
		| CompetitionControllerGetChessMatchResult400Response
		| CompetitionControllerGetChessMatchResult401Response
		| CompetitionControllerGetChessMatchResult403Response
		| CompetitionControllerGetChessMatchResult404Response
		| CompetitionControllerGetChessMatchResult409Response
		| CompetitionControllerGetChessMatchResult422Response
		| CompetitionControllerGetChessMatchResult500Response
		| CompetitionControllerGetChessMatchResultDefaultResponse
	
	export interface CompetitionControllerGetChessMatchResult400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResult500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetChessMatchResultDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessMatchResultDto
		headers?: undefined
	}
	
	export type CompetitionControllerGetLatestChessCompetitionReportResponse =
		| CompetitionControllerGetLatestChessCompetitionReport400Response
		| CompetitionControllerGetLatestChessCompetitionReport401Response
		| CompetitionControllerGetLatestChessCompetitionReport403Response
		| CompetitionControllerGetLatestChessCompetitionReport404Response
		| CompetitionControllerGetLatestChessCompetitionReport409Response
		| CompetitionControllerGetLatestChessCompetitionReport422Response
		| CompetitionControllerGetLatestChessCompetitionReport500Response
		| CompetitionControllerGetLatestChessCompetitionReportDefaultResponse
	
	export interface CompetitionControllerGetLatestChessCompetitionReport400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReport500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerGetLatestChessCompetitionReportDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.CompetitionRunSubmissionReportEntity[]
		headers?: undefined
	}
	
	export type CompetitionControllerListChessAgentsResponse =
		| CompetitionControllerListChessAgents400Response
		| CompetitionControllerListChessAgents401Response
		| CompetitionControllerListChessAgents403Response
		| CompetitionControllerListChessAgents404Response
		| CompetitionControllerListChessAgents409Response
		| CompetitionControllerListChessAgents422Response
		| CompetitionControllerListChessAgents500Response
		| CompetitionControllerListChessAgentsDefaultResponse
	
	export interface CompetitionControllerListChessAgents400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgents500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerListChessAgentsDefaultResponse {
		status: number
		contentType: 'application/json'
		body: string[]
		headers?: undefined
	}
	
	export type CompetitionControllerRequestChessMoveResponse =
		| CompetitionControllerRequestChessMove400Response
		| CompetitionControllerRequestChessMove401Response
		| CompetitionControllerRequestChessMove403Response
		| CompetitionControllerRequestChessMove404Response
		| CompetitionControllerRequestChessMove409Response
		| CompetitionControllerRequestChessMove422Response
		| CompetitionControllerRequestChessMove500Response
		| CompetitionControllerRequestChessMoveDefaultResponse
	
	export interface CompetitionControllerRequestChessMove400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMove500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRequestChessMoveDefaultResponse {
		status: number
		contentType: 'application/json'
		body: string
		headers?: undefined
	}
	
	export type CompetitionControllerRunChessMatchResponse =
		| CompetitionControllerRunChessMatch400Response
		| CompetitionControllerRunChessMatch401Response
		| CompetitionControllerRunChessMatch403Response
		| CompetitionControllerRunChessMatch404Response
		| CompetitionControllerRunChessMatch409Response
		| CompetitionControllerRunChessMatch422Response
		| CompetitionControllerRunChessMatch500Response
		| CompetitionControllerRunChessMatchDefaultResponse
	
	export interface CompetitionControllerRunChessMatch400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatch500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunChessMatchDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.ChessMatchResultDto
		headers?: undefined
	}
	
	export type CompetitionControllerRunCompetitionResponse =
		| CompetitionControllerRunCompetition400Response
		| CompetitionControllerRunCompetition401Response
		| CompetitionControllerRunCompetition403Response
		| CompetitionControllerRunCompetition404Response
		| CompetitionControllerRunCompetition409Response
		| CompetitionControllerRunCompetition422Response
		| CompetitionControllerRunCompetition500Response
	
	export interface CompetitionControllerRunCompetition400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerRunCompetition500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type CompetitionControllerSubmitChessAgentResponse =
		| CompetitionControllerSubmitChessAgent400Response
		| CompetitionControllerSubmitChessAgent401Response
		| CompetitionControllerSubmitChessAgent403Response
		| CompetitionControllerSubmitChessAgent404Response
		| CompetitionControllerSubmitChessAgent409Response
		| CompetitionControllerSubmitChessAgent422Response
		| CompetitionControllerSubmitChessAgent500Response
		| CompetitionControllerSubmitChessAgentDefaultResponse
	
	export interface CompetitionControllerSubmitChessAgent400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgent500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CompetitionControllerSubmitChessAgentDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.TerminalDto[]
		headers?: undefined
	}
	
}

/**
 * CompetitionsApi - fetch parameter creator
 * @export
 */
export const CompetitionsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerFindChessMatchResult.');
			}

			let localVarPath = `/Competitions/Chess/FindMatches`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/Leaderboard`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling competitionControllerGetChessMatchResult.');
			}

			let localVarPath = `/Competitions/Chess/Match/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/LatestCompetitionReport`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/ListAgents`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRequestChessMove.');
			}

			let localVarPath = `/Competitions/Chess/Move`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRunChessMatch.');
			}

			let localVarPath = `/Competitions/Chess/RunMatch`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/RunCompetition`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/Competitions/Chess/submit`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'multipart/form-data');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				const localVarFormData = new FormData();
				if (request.file !== undefined) {
					localVarFormData.append('file', request.file.value);
				}
				localVarRequestOptions.body = localVarFormData;
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * CompetitionsApi - functional programming interface
 * @export
 */
export const CompetitionsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerFindChessMatchResultResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerFindChessMatchResult(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.MatchSearchResponseDto[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetChessLeaderboardResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessLeaderboard(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessLeaderboardResponseEntryDto[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetChessMatchResultResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessMatchResult(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessMatchResultDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerGetLatestChessCompetitionReportResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetLatestChessCompetitionReport(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.CompetitionRunSubmissionReportEntity[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerListChessAgentsResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerListChessAgents(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as string[],
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRequestChessMoveResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRequestChessMove(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as string,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRunChessMatchResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunChessMatch(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.ChessMatchResultDto,
					}
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerRunCompetitionResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunCompetition(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<CompetitionsApi.CompetitionControllerSubmitChessAgentResponse> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerSubmitChessAgent(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.TerminalDto[],
					}
				}
				throw response;
			};
		},
	}
};

/**
 * CompetitionsApi - factory interface
 * @export
 */
export const CompetitionsApiFactory: FactoryFunction<CompetitionsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new CompetitionsApi(configuration, basePath, fetch);
};

/**
 * CompetitionsApi - interface
 * @export
 * @interface CompetitionsApi
 */
export interface CompetitionsApiInterface {
	/**
	 * @param {Api.MatchSearchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerFindChessMatchResultResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetChessLeaderboard(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetChessLeaderboardResponse>

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetChessMatchResult(id: string, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetChessMatchResultResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerGetLatestChessCompetitionReport(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerGetLatestChessCompetitionReportResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerListChessAgents(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerListChessAgentsResponse>

	/**
	 * @param {Api.ChessMoveRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRequestChessMoveResponse>

	/**
	 * @param {Api.ChessMatchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRunChessMatchResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerRunCompetition(options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerRunCompetitionResponse>

	/**
	 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit): Promise<CompetitionsApi.CompetitionControllerSubmitChessAgentResponse>

}

/**
 * CompetitionsApi - object-oriented interface
 * @export
 * @class CompetitionsApi
 * @extends {BaseAPI}
 */
export class CompetitionsApi extends BaseAPI implements CompetitionsApiInterface {
	/**
	 * @param {Api.MatchSearchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerFindChessMatchResult(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessLeaderboard(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessLeaderboard(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessMatchResult(id: string, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessMatchResult(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetLatestChessCompetitionReport(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetLatestChessCompetitionReport(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerListChessAgents(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerListChessAgents(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMoveRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRequestChessMove(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMatchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunChessMatch(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunCompetition(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunCompetition(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerSubmitChessAgent(request, options)(this.fetch, this.basePath);
	}

}
export namespace ContentApi {
	export type ContentControllerCreateEmptyCourseResponse =
		| ContentControllerCreateEmptyCourse400Response
		| ContentControllerCreateEmptyCourse401Response
		| ContentControllerCreateEmptyCourse403Response
		| ContentControllerCreateEmptyCourse404Response
		| ContentControllerCreateEmptyCourse409Response
		| ContentControllerCreateEmptyCourse422Response
		| ContentControllerCreateEmptyCourse500Response
		| ContentControllerCreateEmptyCourseDefaultResponse
	
	export interface ContentControllerCreateEmptyCourse400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourse500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ContentControllerCreateEmptyCourseDefaultResponse {
		status: number
		contentType: 'application/json'
		body: Api.CourseEntity
		headers?: undefined
	}
	
}

/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/content/course/create`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ContentApi.ContentControllerCreateEmptyCourseResponse> {
			const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentControllerCreateEmptyCourse(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				/* Catch-all response */
				if (mimeType === 'application/json') {
					return {
						status: response.status,
						contentType: 'application/json',
						body: await response.json() as Api.CourseEntity,
					}
				}
				throw response;
			};
		},
	}
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory: FactoryFunction<ContentApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ContentApi(configuration, basePath, fetch);
};

/**
 * ContentApi - interface
 * @export
 * @interface ContentApi
 */
export interface ContentApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	contentControllerCreateEmptyCourse(options?: RequestInit): Promise<ContentApi.ContentControllerCreateEmptyCourseResponse>

}

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI implements ContentApiInterface {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public contentControllerCreateEmptyCourse(options?: RequestInit) {
		return ContentApiFp(this.configuration).contentControllerCreateEmptyCourse(options)(this.fetch, this.basePath);
	}

}
export namespace JobApplicationsApi {
	export type CreateOneBaseJobApplicationControllerJobApplicationEntityResponse =
		| CreateOneBaseJobApplicationControllerJobApplicationEntity201Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity400Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity401Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity403Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity404Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity409Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity422Response
		| CreateOneBaseJobApplicationControllerJobApplicationEntity500Response
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity201Response {
		status: 201
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobApplicationControllerJobApplicationEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type DeleteOneBaseJobApplicationControllerJobApplicationEntityResponse =
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity200Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity400Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity401Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity403Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity404Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity409Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity422Response
		| DeleteOneBaseJobApplicationControllerJobApplicationEntity500Response
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobApplicationControllerJobApplicationEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntityParameters {
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @type {string}
		 */
		s?: string
		/**
		 * @description <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		filter?: string[]
		/**
		 * @description <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		or?: string[]
		/**
		 * @description <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		sort?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		offset?: number
		/**
		 * @description <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		page?: number
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetManyBaseJobApplicationControllerJobApplicationEntityResponse =
		| GetManyBaseJobApplicationControllerJobApplicationEntity200Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity400Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity401Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity403Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity404Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity409Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity422Response
		| GetManyBaseJobApplicationControllerJobApplicationEntity500Response
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetManyJobApplicationEntityResponseDto | Api.JobApplicationEntity[]
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobApplicationControllerJobApplicationEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntityParameters {
		id: string
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetOneBaseJobApplicationControllerJobApplicationEntityResponse =
		| GetOneBaseJobApplicationControllerJobApplicationEntity200Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity400Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity401Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity403Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity404Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity409Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity422Response
		| GetOneBaseJobApplicationControllerJobApplicationEntity500Response
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobApplicationControllerJobApplicationEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type UpdateOneBaseJobApplicationControllerJobApplicationEntityResponse =
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity200Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity400Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity401Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity403Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity404Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity409Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity422Response
		| UpdateOneBaseJobApplicationControllerJobApplicationEntity500Response
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobApplicationEntity
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobApplicationControllerJobApplicationEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobApplicationsApi - fetch parameter creator
 * @export
 */
export const JobApplicationsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobApplicationEntity
		 * @param {Api.JobAplicationCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobApplicationControllerJobApplicationEntity(request: Api.JobAplicationCreateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseJobApplicationControllerJobApplicationEntity.');
			}

			let localVarPath = `/job-applications`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single JobApplicationEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobApplicationControllerJobApplicationEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseJobApplicationControllerJobApplicationEntity.');
			}

			let localVarPath = `/job-applications/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple JobApplicationEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-applications`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.s !== undefined) {
				localVarQueryParameter.append('s', String(__params.s));
			}

			if (__params.filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.page !== undefined) {
				localVarQueryParameter.append('page', String(__params.page));
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single JobApplicationEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseJobApplicationControllerJobApplicationEntity.');
			}

			let localVarPath = `/job-applications/{id}`
				.replace('{id}', encodeURIComponent(String(__params.id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a single JobApplicationEntity
		 * @param {string} id
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobApplicationControllerJobApplicationEntity(id: string, request: Api.JobApplicationEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOneBaseJobApplicationControllerJobApplicationEntity.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateOneBaseJobApplicationControllerJobApplicationEntity.');
			}

			let localVarPath = `/job-applications/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobApplicationsApi - functional programming interface
 * @export
 */
export const JobApplicationsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobApplicationEntity
		 * @param {Api.JobAplicationCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobApplicationControllerJobApplicationEntity(request: Api.JobAplicationCreateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.CreateOneBaseJobApplicationControllerJobApplicationEntityResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).createOneBaseJobApplicationControllerJobApplicationEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Delete a single JobApplicationEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobApplicationControllerJobApplicationEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.DeleteOneBaseJobApplicationControllerJobApplicationEntityResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).deleteOneBaseJobApplicationControllerJobApplicationEntity(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve multiple JobApplicationEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).getManyBaseJobApplicationControllerJobApplicationEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.GetManyJobApplicationEntityResponseDto | Api.JobApplicationEntity[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve a single JobApplicationEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).getOneBaseJobApplicationControllerJobApplicationEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Update a single JobApplicationEntity
		 * @param {string} id
		 * @param {Api.JobApplicationEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobApplicationControllerJobApplicationEntity(id: string, request: Api.JobApplicationEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobApplicationsApi.UpdateOneBaseJobApplicationControllerJobApplicationEntityResponse> {
			const localVarFetchArgs = JobApplicationsApiFetchParamCreator(configuration).updateOneBaseJobApplicationControllerJobApplicationEntity(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobApplicationEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobApplicationsApi - factory interface
 * @export
 */
export const JobApplicationsApiFactory: FactoryFunction<JobApplicationsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobApplicationsApi(configuration, basePath, fetch);
};

/**
 * JobApplicationsApi - interface
 * @export
 * @interface JobApplicationsApi
 */
export interface JobApplicationsApiInterface {
	/**
	 * @summary Create a single JobApplicationEntity
	 * @param {Api.JobAplicationCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createOneBaseJobApplicationControllerJobApplicationEntity(request: Api.JobAplicationCreateDto, options?: RequestInit): Promise<JobApplicationsApi.CreateOneBaseJobApplicationControllerJobApplicationEntityResponse>

	/**
	 * @summary Delete a single JobApplicationEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOneBaseJobApplicationControllerJobApplicationEntity(id: string, options?: RequestInit): Promise<JobApplicationsApi.DeleteOneBaseJobApplicationControllerJobApplicationEntityResponse>

	/**
	 * @summary Retrieve multiple JobApplicationEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getManyBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit): Promise<JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityResponse>

	/**
	 * @summary Retrieve a single JobApplicationEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOneBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit): Promise<JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityResponse>

	/**
	 * @summary Update a single JobApplicationEntity
	 * @param {string} id
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updateOneBaseJobApplicationControllerJobApplicationEntity(id: string, request: Api.JobApplicationEntity, options?: RequestInit): Promise<JobApplicationsApi.UpdateOneBaseJobApplicationControllerJobApplicationEntityResponse>

}

/**
 * JobApplicationsApi - object-oriented interface
 * @export
 * @class JobApplicationsApi
 * @extends {BaseAPI}
 */
export class JobApplicationsApi extends BaseAPI implements JobApplicationsApiInterface {
	/**
	 * @summary Create a single JobApplicationEntity
	 * @param {Api.JobAplicationCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseJobApplicationControllerJobApplicationEntity(request: Api.JobAplicationCreateDto, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).createOneBaseJobApplicationControllerJobApplicationEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single JobApplicationEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseJobApplicationControllerJobApplicationEntity(id: string, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).deleteOneBaseJobApplicationControllerJobApplicationEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple JobApplicationEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetManyBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).getManyBaseJobApplicationControllerJobApplicationEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single JobApplicationEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseJobApplicationControllerJobApplicationEntity(__params: JobApplicationsApi.GetOneBaseJobApplicationControllerJobApplicationEntityParameters, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).getOneBaseJobApplicationControllerJobApplicationEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a single JobApplicationEntity
	 * @param {string} id
	 * @param {Api.JobApplicationEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateOneBaseJobApplicationControllerJobApplicationEntity(id: string, request: Api.JobApplicationEntity, options?: RequestInit) {
		return JobApplicationsApiFp(this.configuration).updateOneBaseJobApplicationControllerJobApplicationEntity(id, request, options)(this.fetch, this.basePath);
	}

}
export namespace JobPostsApi {
	export type CreateOneBaseJobPostControllerJobPostEntityResponse =
		| CreateOneBaseJobPostControllerJobPostEntity201Response
		| CreateOneBaseJobPostControllerJobPostEntity400Response
		| CreateOneBaseJobPostControllerJobPostEntity401Response
		| CreateOneBaseJobPostControllerJobPostEntity403Response
		| CreateOneBaseJobPostControllerJobPostEntity404Response
		| CreateOneBaseJobPostControllerJobPostEntity409Response
		| CreateOneBaseJobPostControllerJobPostEntity422Response
		| CreateOneBaseJobPostControllerJobPostEntity500Response
	
	export interface CreateOneBaseJobPostControllerJobPostEntity201Response {
		status: 201
		contentType: 'application/json'
		body: Api.JobPostEntity
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobPostControllerJobPostEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type DeleteOneBaseJobPostControllerJobPostEntityResponse =
		| DeleteOneBaseJobPostControllerJobPostEntity200Response
		| DeleteOneBaseJobPostControllerJobPostEntity400Response
		| DeleteOneBaseJobPostControllerJobPostEntity401Response
		| DeleteOneBaseJobPostControllerJobPostEntity403Response
		| DeleteOneBaseJobPostControllerJobPostEntity404Response
		| DeleteOneBaseJobPostControllerJobPostEntity409Response
		| DeleteOneBaseJobPostControllerJobPostEntity422Response
		| DeleteOneBaseJobPostControllerJobPostEntity500Response
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobPostControllerJobPostEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobPostControllerJobPostEntityParameters {
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @type {string}
		 */
		s?: string
		/**
		 * @description <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		filter?: string[]
		/**
		 * @description <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		or?: string[]
		/**
		 * @description <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		sort?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		offset?: number
		/**
		 * @description <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		page?: number
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetManyBaseJobPostControllerJobPostEntityResponse =
		| GetManyBaseJobPostControllerJobPostEntity200Response
	
	export interface GetManyBaseJobPostControllerJobPostEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetManyJobPostEntityResponseDto | Api.JobPostEntity[]
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntityParameters {
		id: string
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetOneBaseJobPostControllerJobPostEntityResponse =
		| GetOneBaseJobPostControllerJobPostEntity200Response
		| GetOneBaseJobPostControllerJobPostEntity400Response
		| GetOneBaseJobPostControllerJobPostEntity401Response
		| GetOneBaseJobPostControllerJobPostEntity403Response
		| GetOneBaseJobPostControllerJobPostEntity404Response
		| GetOneBaseJobPostControllerJobPostEntity409Response
		| GetOneBaseJobPostControllerJobPostEntity422Response
		| GetOneBaseJobPostControllerJobPostEntity500Response
	
	export interface GetOneBaseJobPostControllerJobPostEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobPostEntity
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobPostControllerJobPostEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerAddEditorResponse =
		| JobPostControllerAddEditor400Response
		| JobPostControllerAddEditor401Response
		| JobPostControllerAddEditor403Response
		| JobPostControllerAddEditor404Response
		| JobPostControllerAddEditor409Response
		| JobPostControllerAddEditor422Response
		| JobPostControllerAddEditor500Response
	
	export interface JobPostControllerAddEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerAddEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerRemoveEditorResponse =
		| JobPostControllerRemoveEditor400Response
		| JobPostControllerRemoveEditor401Response
		| JobPostControllerRemoveEditor403Response
		| JobPostControllerRemoveEditor404Response
		| JobPostControllerRemoveEditor409Response
		| JobPostControllerRemoveEditor422Response
		| JobPostControllerRemoveEditor500Response
	
	export interface JobPostControllerRemoveEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerRemoveEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type JobPostControllerSwitchOwnerResponse =
		| JobPostControllerSwitchOwner400Response
		| JobPostControllerSwitchOwner401Response
		| JobPostControllerSwitchOwner403Response
		| JobPostControllerSwitchOwner404Response
		| JobPostControllerSwitchOwner409Response
		| JobPostControllerSwitchOwner422Response
		| JobPostControllerSwitchOwner500Response
	
	export interface JobPostControllerSwitchOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface JobPostControllerSwitchOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type UpdateOneBaseJobPostControllerJobPostEntityResponse =
		| UpdateOneBaseJobPostControllerJobPostEntity200Response
		| UpdateOneBaseJobPostControllerJobPostEntity400Response
		| UpdateOneBaseJobPostControllerJobPostEntity401Response
		| UpdateOneBaseJobPostControllerJobPostEntity403Response
		| UpdateOneBaseJobPostControllerJobPostEntity404Response
		| UpdateOneBaseJobPostControllerJobPostEntity409Response
		| UpdateOneBaseJobPostControllerJobPostEntity422Response
		| UpdateOneBaseJobPostControllerJobPostEntity500Response
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobPostEntity
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobPostControllerJobPostEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobPostsApi - fetch parameter creator
 * @export
 */
export const JobPostsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobPostEntity
		 * @param {Api.JobPostCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobPostControllerJobPostEntity(request: Api.JobPostCreateDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseJobPostControllerJobPostEntity.');
			}

			let localVarPath = `/job-posts`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single JobPostEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobPostControllerJobPostEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseJobPostControllerJobPostEntity.');
			}

			let localVarPath = `/job-posts/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple JobPostEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetManyBaseJobPostControllerJobPostEntityParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-posts`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.s !== undefined) {
				localVarQueryParameter.append('s', String(__params.s));
			}

			if (__params.filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.page !== undefined) {
				localVarQueryParameter.append('page', String(__params.page));
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single JobPostEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetOneBaseJobPostControllerJobPostEntityParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseJobPostControllerJobPostEntity.');
			}

			let localVarPath = `/job-posts/{id}`
				.replace('{id}', encodeURIComponent(String(__params.id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerAddEditor.');
			}

			let localVarPath = `/job-posts/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerRemoveEditor.');
			}

			let localVarPath = `/job-posts/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling jobPostControllerSwitchOwner.');
			}

			let localVarPath = `/job-posts/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a single JobPostEntity
		 * @param {string} id
		 * @param {Api.JobPostEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobPostControllerJobPostEntity(id: string, request: Api.JobPostEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOneBaseJobPostControllerJobPostEntity.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateOneBaseJobPostControllerJobPostEntity.');
			}

			let localVarPath = `/job-posts/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobPostsApi - functional programming interface
 * @export
 */
export const JobPostsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobPostEntity
		 * @param {Api.JobPostCreateDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobPostControllerJobPostEntity(request: Api.JobPostCreateDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.CreateOneBaseJobPostControllerJobPostEntityResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).createOneBaseJobPostControllerJobPostEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Delete a single JobPostEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobPostControllerJobPostEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.DeleteOneBaseJobPostControllerJobPostEntityResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).deleteOneBaseJobPostControllerJobPostEntity(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve multiple JobPostEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetManyBaseJobPostControllerJobPostEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.GetManyBaseJobPostControllerJobPostEntityResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).getManyBaseJobPostControllerJobPostEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.GetManyJobPostEntityResponseDto | Api.JobPostEntity[],
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve a single JobPostEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetOneBaseJobPostControllerJobPostEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.GetOneBaseJobPostControllerJobPostEntityResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).getOneBaseJobPostControllerJobPostEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerAddEditorResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerAddEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerRemoveEditorResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerRemoveEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.JobPostControllerSwitchOwnerResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).jobPostControllerSwitchOwner(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Update a single JobPostEntity
		 * @param {string} id
		 * @param {Api.JobPostEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobPostControllerJobPostEntity(id: string, request: Api.JobPostEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobPostsApi.UpdateOneBaseJobPostControllerJobPostEntityResponse> {
			const localVarFetchArgs = JobPostsApiFetchParamCreator(configuration).updateOneBaseJobPostControllerJobPostEntity(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobPostEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobPostsApi - factory interface
 * @export
 */
export const JobPostsApiFactory: FactoryFunction<JobPostsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobPostsApi(configuration, basePath, fetch);
};

/**
 * JobPostsApi - interface
 * @export
 * @interface JobPostsApi
 */
export interface JobPostsApiInterface {
	/**
	 * @summary Create a single JobPostEntity
	 * @param {Api.JobPostCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createOneBaseJobPostControllerJobPostEntity(request: Api.JobPostCreateDto, options?: RequestInit): Promise<JobPostsApi.CreateOneBaseJobPostControllerJobPostEntityResponse>

	/**
	 * @summary Delete a single JobPostEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOneBaseJobPostControllerJobPostEntity(id: string, options?: RequestInit): Promise<JobPostsApi.DeleteOneBaseJobPostControllerJobPostEntityResponse>

	/**
	 * @summary Retrieve multiple JobPostEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getManyBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetManyBaseJobPostControllerJobPostEntityParameters, options?: RequestInit): Promise<JobPostsApi.GetManyBaseJobPostControllerJobPostEntityResponse>

	/**
	 * @summary Retrieve a single JobPostEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOneBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetOneBaseJobPostControllerJobPostEntityParameters, options?: RequestInit): Promise<JobPostsApi.GetOneBaseJobPostControllerJobPostEntityResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerAddEditorResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerRemoveEditorResponse>

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): Promise<JobPostsApi.JobPostControllerSwitchOwnerResponse>

	/**
	 * @summary Update a single JobPostEntity
	 * @param {string} id
	 * @param {Api.JobPostEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updateOneBaseJobPostControllerJobPostEntity(id: string, request: Api.JobPostEntity, options?: RequestInit): Promise<JobPostsApi.UpdateOneBaseJobPostControllerJobPostEntityResponse>

}

/**
 * JobPostsApi - object-oriented interface
 * @export
 * @class JobPostsApi
 * @extends {BaseAPI}
 */
export class JobPostsApi extends BaseAPI implements JobPostsApiInterface {
	/**
	 * @summary Create a single JobPostEntity
	 * @param {Api.JobPostCreateDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseJobPostControllerJobPostEntity(request: Api.JobPostCreateDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).createOneBaseJobPostControllerJobPostEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single JobPostEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseJobPostControllerJobPostEntity(id: string, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).deleteOneBaseJobPostControllerJobPostEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple JobPostEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetManyBaseJobPostControllerJobPostEntityParameters, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).getManyBaseJobPostControllerJobPostEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single JobPostEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseJobPostControllerJobPostEntity(__params: JobPostsApi.GetOneBaseJobPostControllerJobPostEntityParameters, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).getOneBaseJobPostControllerJobPostEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public jobPostControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).jobPostControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a single JobPostEntity
	 * @param {string} id
	 * @param {Api.JobPostEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateOneBaseJobPostControllerJobPostEntity(id: string, request: Api.JobPostEntity, options?: RequestInit) {
		return JobPostsApiFp(this.configuration).updateOneBaseJobPostControllerJobPostEntity(id, request, options)(this.fetch, this.basePath);
	}

}
export namespace JobTagsApi {
	export type CreateOneBaseJobTagControllerJobTagEntityResponse =
		| CreateOneBaseJobTagControllerJobTagEntity201Response
		| CreateOneBaseJobTagControllerJobTagEntity400Response
		| CreateOneBaseJobTagControllerJobTagEntity401Response
		| CreateOneBaseJobTagControllerJobTagEntity403Response
		| CreateOneBaseJobTagControllerJobTagEntity404Response
		| CreateOneBaseJobTagControllerJobTagEntity409Response
		| CreateOneBaseJobTagControllerJobTagEntity422Response
		| CreateOneBaseJobTagControllerJobTagEntity500Response
	
	export interface CreateOneBaseJobTagControllerJobTagEntity201Response {
		status: 201
		contentType: 'application/json'
		body: Api.JobTagEntity
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseJobTagControllerJobTagEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type DeleteOneBaseJobTagControllerJobTagEntityResponse =
		| DeleteOneBaseJobTagControllerJobTagEntity200Response
		| DeleteOneBaseJobTagControllerJobTagEntity400Response
		| DeleteOneBaseJobTagControllerJobTagEntity401Response
		| DeleteOneBaseJobTagControllerJobTagEntity403Response
		| DeleteOneBaseJobTagControllerJobTagEntity404Response
		| DeleteOneBaseJobTagControllerJobTagEntity409Response
		| DeleteOneBaseJobTagControllerJobTagEntity422Response
		| DeleteOneBaseJobTagControllerJobTagEntity500Response
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseJobTagControllerJobTagEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntityParameters {
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @type {string}
		 */
		s?: string
		/**
		 * @description <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		filter?: string[]
		/**
		 * @description <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		or?: string[]
		/**
		 * @description <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		sort?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		offset?: number
		/**
		 * @description <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		page?: number
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetManyBaseJobTagControllerJobTagEntityResponse =
		| GetManyBaseJobTagControllerJobTagEntity200Response
		| GetManyBaseJobTagControllerJobTagEntity400Response
		| GetManyBaseJobTagControllerJobTagEntity401Response
		| GetManyBaseJobTagControllerJobTagEntity403Response
		| GetManyBaseJobTagControllerJobTagEntity404Response
		| GetManyBaseJobTagControllerJobTagEntity409Response
		| GetManyBaseJobTagControllerJobTagEntity422Response
		| GetManyBaseJobTagControllerJobTagEntity500Response
	
	export interface GetManyBaseJobTagControllerJobTagEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetManyJobTagEntityResponseDto | Api.JobTagEntity[]
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseJobTagControllerJobTagEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntityParameters {
		id: string
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetOneBaseJobTagControllerJobTagEntityResponse =
		| GetOneBaseJobTagControllerJobTagEntity200Response
		| GetOneBaseJobTagControllerJobTagEntity400Response
		| GetOneBaseJobTagControllerJobTagEntity401Response
		| GetOneBaseJobTagControllerJobTagEntity403Response
		| GetOneBaseJobTagControllerJobTagEntity404Response
		| GetOneBaseJobTagControllerJobTagEntity409Response
		| GetOneBaseJobTagControllerJobTagEntity422Response
		| GetOneBaseJobTagControllerJobTagEntity500Response
	
	export interface GetOneBaseJobTagControllerJobTagEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobTagEntity
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseJobTagControllerJobTagEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type UpdateOneBaseJobTagControllerJobTagEntityResponse =
		| UpdateOneBaseJobTagControllerJobTagEntity200Response
		| UpdateOneBaseJobTagControllerJobTagEntity400Response
		| UpdateOneBaseJobTagControllerJobTagEntity401Response
		| UpdateOneBaseJobTagControllerJobTagEntity403Response
		| UpdateOneBaseJobTagControllerJobTagEntity404Response
		| UpdateOneBaseJobTagControllerJobTagEntity409Response
		| UpdateOneBaseJobTagControllerJobTagEntity422Response
		| UpdateOneBaseJobTagControllerJobTagEntity500Response
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.JobTagEntity
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseJobTagControllerJobTagEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * JobTagsApi - fetch parameter creator
 * @export
 */
export const JobTagsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobTagEntity
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobTagControllerJobTagEntity(request: Api.JobTagEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseJobTagControllerJobTagEntity.');
			}

			let localVarPath = `/job-tags`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single JobTagEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobTagControllerJobTagEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseJobTagControllerJobTagEntity.');
			}

			let localVarPath = `/job-tags/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple JobTagEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetManyBaseJobTagControllerJobTagEntityParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/job-tags`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.s !== undefined) {
				localVarQueryParameter.append('s', String(__params.s));
			}

			if (__params.filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.page !== undefined) {
				localVarQueryParameter.append('page', String(__params.page));
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single JobTagEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetOneBaseJobTagControllerJobTagEntityParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseJobTagControllerJobTagEntity.');
			}

			let localVarPath = `/job-tags/{id}`
				.replace('{id}', encodeURIComponent(String(__params.id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a single JobTagEntity
		 * @param {string} id
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobTagControllerJobTagEntity(id: string, request: Api.JobTagEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOneBaseJobTagControllerJobTagEntity.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateOneBaseJobTagControllerJobTagEntity.');
			}

			let localVarPath = `/job-tags/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * JobTagsApi - functional programming interface
 * @export
 */
export const JobTagsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single JobTagEntity
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseJobTagControllerJobTagEntity(request: Api.JobTagEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.CreateOneBaseJobTagControllerJobTagEntityResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).createOneBaseJobTagControllerJobTagEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobTagEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Delete a single JobTagEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseJobTagControllerJobTagEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.DeleteOneBaseJobTagControllerJobTagEntityResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).deleteOneBaseJobTagControllerJobTagEntity(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve multiple JobTagEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetManyBaseJobTagControllerJobTagEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.GetManyBaseJobTagControllerJobTagEntityResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).getManyBaseJobTagControllerJobTagEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.GetManyJobTagEntityResponseDto | Api.JobTagEntity[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve a single JobTagEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetOneBaseJobTagControllerJobTagEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.GetOneBaseJobTagControllerJobTagEntityResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).getOneBaseJobTagControllerJobTagEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobTagEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Update a single JobTagEntity
		 * @param {string} id
		 * @param {Api.JobTagEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseJobTagControllerJobTagEntity(id: string, request: Api.JobTagEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<JobTagsApi.UpdateOneBaseJobTagControllerJobTagEntityResponse> {
			const localVarFetchArgs = JobTagsApiFetchParamCreator(configuration).updateOneBaseJobTagControllerJobTagEntity(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.JobTagEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * JobTagsApi - factory interface
 * @export
 */
export const JobTagsApiFactory: FactoryFunction<JobTagsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new JobTagsApi(configuration, basePath, fetch);
};

/**
 * JobTagsApi - interface
 * @export
 * @interface JobTagsApi
 */
export interface JobTagsApiInterface {
	/**
	 * @summary Create a single JobTagEntity
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createOneBaseJobTagControllerJobTagEntity(request: Api.JobTagEntity, options?: RequestInit): Promise<JobTagsApi.CreateOneBaseJobTagControllerJobTagEntityResponse>

	/**
	 * @summary Delete a single JobTagEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOneBaseJobTagControllerJobTagEntity(id: string, options?: RequestInit): Promise<JobTagsApi.DeleteOneBaseJobTagControllerJobTagEntityResponse>

	/**
	 * @summary Retrieve multiple JobTagEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getManyBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetManyBaseJobTagControllerJobTagEntityParameters, options?: RequestInit): Promise<JobTagsApi.GetManyBaseJobTagControllerJobTagEntityResponse>

	/**
	 * @summary Retrieve a single JobTagEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOneBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetOneBaseJobTagControllerJobTagEntityParameters, options?: RequestInit): Promise<JobTagsApi.GetOneBaseJobTagControllerJobTagEntityResponse>

	/**
	 * @summary Update a single JobTagEntity
	 * @param {string} id
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updateOneBaseJobTagControllerJobTagEntity(id: string, request: Api.JobTagEntity, options?: RequestInit): Promise<JobTagsApi.UpdateOneBaseJobTagControllerJobTagEntityResponse>

}

/**
 * JobTagsApi - object-oriented interface
 * @export
 * @class JobTagsApi
 * @extends {BaseAPI}
 */
export class JobTagsApi extends BaseAPI implements JobTagsApiInterface {
	/**
	 * @summary Create a single JobTagEntity
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseJobTagControllerJobTagEntity(request: Api.JobTagEntity, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).createOneBaseJobTagControllerJobTagEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single JobTagEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseJobTagControllerJobTagEntity(id: string, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).deleteOneBaseJobTagControllerJobTagEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple JobTagEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetManyBaseJobTagControllerJobTagEntityParameters, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).getManyBaseJobTagControllerJobTagEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single JobTagEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseJobTagControllerJobTagEntity(__params: JobTagsApi.GetOneBaseJobTagControllerJobTagEntityParameters, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).getOneBaseJobTagControllerJobTagEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a single JobTagEntity
	 * @param {string} id
	 * @param {Api.JobTagEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateOneBaseJobTagControllerJobTagEntity(id: string, request: Api.JobTagEntity, options?: RequestInit) {
		return JobTagsApiFp(this.configuration).updateOneBaseJobTagControllerJobTagEntity(id, request, options)(this.fetch, this.basePath);
	}

}
export namespace ProjectApi {
	export type CreateOneBaseProjectControllerProjectEntityResponse =
		| CreateOneBaseProjectControllerProjectEntity201Response
		| CreateOneBaseProjectControllerProjectEntity400Response
		| CreateOneBaseProjectControllerProjectEntity401Response
		| CreateOneBaseProjectControllerProjectEntity403Response
		| CreateOneBaseProjectControllerProjectEntity404Response
		| CreateOneBaseProjectControllerProjectEntity409Response
		| CreateOneBaseProjectControllerProjectEntity422Response
		| CreateOneBaseProjectControllerProjectEntity500Response
	
	export interface CreateOneBaseProjectControllerProjectEntity201Response {
		status: 201
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectControllerProjectEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type DeleteOneBaseProjectControllerProjectEntityResponse =
		| DeleteOneBaseProjectControllerProjectEntity200Response
		| DeleteOneBaseProjectControllerProjectEntity400Response
		| DeleteOneBaseProjectControllerProjectEntity401Response
		| DeleteOneBaseProjectControllerProjectEntity403Response
		| DeleteOneBaseProjectControllerProjectEntity404Response
		| DeleteOneBaseProjectControllerProjectEntity409Response
		| DeleteOneBaseProjectControllerProjectEntity422Response
		| DeleteOneBaseProjectControllerProjectEntity500Response
	
	export interface DeleteOneBaseProjectControllerProjectEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectControllerProjectEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntityParameters {
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @type {string}
		 */
		s?: string
		/**
		 * @description <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		filter?: string[]
		/**
		 * @description <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		or?: string[]
		/**
		 * @description <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		sort?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		offset?: number
		/**
		 * @description <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		page?: number
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetManyBaseProjectControllerProjectEntityResponse =
		| GetManyBaseProjectControllerProjectEntity200Response
		| GetManyBaseProjectControllerProjectEntity400Response
		| GetManyBaseProjectControllerProjectEntity401Response
		| GetManyBaseProjectControllerProjectEntity403Response
		| GetManyBaseProjectControllerProjectEntity404Response
		| GetManyBaseProjectControllerProjectEntity409Response
		| GetManyBaseProjectControllerProjectEntity422Response
		| GetManyBaseProjectControllerProjectEntity500Response
	
	export interface GetManyBaseProjectControllerProjectEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetManyProjectEntityResponseDto | Api.ProjectEntity[]
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectControllerProjectEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntityParameters {
		id: string
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetOneBaseProjectControllerProjectEntityResponse =
		| GetOneBaseProjectControllerProjectEntity200Response
		| GetOneBaseProjectControllerProjectEntity400Response
		| GetOneBaseProjectControllerProjectEntity401Response
		| GetOneBaseProjectControllerProjectEntity403Response
		| GetOneBaseProjectControllerProjectEntity404Response
		| GetOneBaseProjectControllerProjectEntity409Response
		| GetOneBaseProjectControllerProjectEntity422Response
		| GetOneBaseProjectControllerProjectEntity500Response
	
	export interface GetOneBaseProjectControllerProjectEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectControllerProjectEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerAddEditorResponse =
		| ProjectControllerAddEditor400Response
		| ProjectControllerAddEditor401Response
		| ProjectControllerAddEditor403Response
		| ProjectControllerAddEditor404Response
		| ProjectControllerAddEditor409Response
		| ProjectControllerAddEditor422Response
		| ProjectControllerAddEditor500Response
	
	export interface ProjectControllerAddEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerAddEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerRemoveEditorResponse =
		| ProjectControllerRemoveEditor400Response
		| ProjectControllerRemoveEditor401Response
		| ProjectControllerRemoveEditor403Response
		| ProjectControllerRemoveEditor404Response
		| ProjectControllerRemoveEditor409Response
		| ProjectControllerRemoveEditor422Response
		| ProjectControllerRemoveEditor500Response
	
	export interface ProjectControllerRemoveEditor400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerRemoveEditor500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type ProjectControllerSwitchOwnerResponse =
		| ProjectControllerSwitchOwner400Response
		| ProjectControllerSwitchOwner401Response
		| ProjectControllerSwitchOwner403Response
		| ProjectControllerSwitchOwner404Response
		| ProjectControllerSwitchOwner409Response
		| ProjectControllerSwitchOwner422Response
		| ProjectControllerSwitchOwner500Response
	
	export interface ProjectControllerSwitchOwner400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface ProjectControllerSwitchOwner500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type UpdateOneBaseProjectControllerProjectEntityResponse =
		| UpdateOneBaseProjectControllerProjectEntity200Response
		| UpdateOneBaseProjectControllerProjectEntity400Response
		| UpdateOneBaseProjectControllerProjectEntity401Response
		| UpdateOneBaseProjectControllerProjectEntity403Response
		| UpdateOneBaseProjectControllerProjectEntity404Response
		| UpdateOneBaseProjectControllerProjectEntity409Response
		| UpdateOneBaseProjectControllerProjectEntity422Response
		| UpdateOneBaseProjectControllerProjectEntity500Response
	
	export interface UpdateOneBaseProjectControllerProjectEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ProjectEntity
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface UpdateOneBaseProjectControllerProjectEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectEntity
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseProjectControllerProjectEntity.');
			}

			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single ProjectEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectControllerProjectEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseProjectControllerProjectEntity.');
			}

			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple ProjectEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectControllerProjectEntity(__params: ProjectApi.GetManyBaseProjectControllerProjectEntityParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.s !== undefined) {
				localVarQueryParameter.append('s', String(__params.s));
			}

			if (__params.filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.page !== undefined) {
				localVarQueryParameter.append('page', String(__params.page));
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single ProjectEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectControllerProjectEntity(__params: ProjectApi.GetOneBaseProjectControllerProjectEntityParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseProjectControllerProjectEntity.');
			}

			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(__params.id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerAddEditor.');
			}

			let localVarPath = `/project/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerRemoveEditor.');
			}

			let localVarPath = `/project/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerSwitchOwner.');
			}

			let localVarPath = `/project/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a single ProjectEntity
		 * @param {string} id
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOneBaseProjectControllerProjectEntity.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateOneBaseProjectControllerProjectEntity.');
			}

			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectEntity
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.CreateOneBaseProjectControllerProjectEntityResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).createOneBaseProjectControllerProjectEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ProjectEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Delete a single ProjectEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectControllerProjectEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.DeleteOneBaseProjectControllerProjectEntityResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).deleteOneBaseProjectControllerProjectEntity(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve multiple ProjectEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectControllerProjectEntity(__params: ProjectApi.GetManyBaseProjectControllerProjectEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.GetManyBaseProjectControllerProjectEntityResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getManyBaseProjectControllerProjectEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.GetManyProjectEntityResponseDto | Api.ProjectEntity[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve a single ProjectEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectControllerProjectEntity(__params: ProjectApi.GetOneBaseProjectControllerProjectEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.GetOneBaseProjectControllerProjectEntityResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getOneBaseProjectControllerProjectEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ProjectEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerAddEditorResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerAddEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerRemoveEditorResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerRemoveEditor(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.ProjectControllerSwitchOwnerResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerSwitchOwner(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Update a single ProjectEntity
		 * @param {string} id
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectApi.UpdateOneBaseProjectControllerProjectEntityResponse> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).updateOneBaseProjectControllerProjectEntity(id, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ProjectEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory: FactoryFunction<ProjectApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectApi(configuration, basePath, fetch);
};

/**
 * ProjectApi - interface
 * @export
 * @interface ProjectApi
 */
export interface ProjectApiInterface {
	/**
	 * @summary Create a single ProjectEntity
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options?: RequestInit): Promise<ProjectApi.CreateOneBaseProjectControllerProjectEntityResponse>

	/**
	 * @summary Delete a single ProjectEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOneBaseProjectControllerProjectEntity(id: string, options?: RequestInit): Promise<ProjectApi.DeleteOneBaseProjectControllerProjectEntityResponse>

	/**
	 * @summary Retrieve multiple ProjectEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getManyBaseProjectControllerProjectEntity(__params: ProjectApi.GetManyBaseProjectControllerProjectEntityParameters, options?: RequestInit): Promise<ProjectApi.GetManyBaseProjectControllerProjectEntityResponse>

	/**
	 * @summary Retrieve a single ProjectEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOneBaseProjectControllerProjectEntity(__params: ProjectApi.GetOneBaseProjectControllerProjectEntityParameters, options?: RequestInit): Promise<ProjectApi.GetOneBaseProjectControllerProjectEntityResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerAddEditorResponse>

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerRemoveEditorResponse>

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): Promise<ProjectApi.ProjectControllerSwitchOwnerResponse>

	/**
	 * @summary Update a single ProjectEntity
	 * @param {string} id
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options?: RequestInit): Promise<ProjectApi.UpdateOneBaseProjectControllerProjectEntityResponse>

}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI implements ProjectApiInterface {
	/**
	 * @summary Create a single ProjectEntity
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options?: RequestInit) {
		return ProjectApiFp(this.configuration).createOneBaseProjectControllerProjectEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single ProjectEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseProjectControllerProjectEntity(id: string, options?: RequestInit) {
		return ProjectApiFp(this.configuration).deleteOneBaseProjectControllerProjectEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple ProjectEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseProjectControllerProjectEntity(__params: ProjectApi.GetManyBaseProjectControllerProjectEntityParameters, options?: RequestInit) {
		return ProjectApiFp(this.configuration).getManyBaseProjectControllerProjectEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single ProjectEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseProjectControllerProjectEntity(__params: ProjectApi.GetOneBaseProjectControllerProjectEntityParameters, options?: RequestInit) {
		return ProjectApiFp(this.configuration).getOneBaseProjectControllerProjectEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a single ProjectEntity
	 * @param {string} id
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options?: RequestInit) {
		return ProjectApiFp(this.configuration).updateOneBaseProjectControllerProjectEntity(id, request, options)(this.fetch, this.basePath);
	}

}
export namespace ProjectVersionApi {
	export type CreateOneBaseProjectVersionControllerProjectVersionEntityResponse =
		| CreateOneBaseProjectVersionControllerProjectVersionEntity201Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity400Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity401Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity403Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity404Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity409Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity422Response
		| CreateOneBaseProjectVersionControllerProjectVersionEntity500Response
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity201Response {
		status: 201
		contentType: 'application/json'
		body: Api.ProjectVersionEntity
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface CreateOneBaseProjectVersionControllerProjectVersionEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export type DeleteOneBaseProjectVersionControllerProjectVersionEntityResponse =
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity200Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity400Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity401Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity403Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity404Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity409Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity422Response
		| DeleteOneBaseProjectVersionControllerProjectVersionEntity500Response
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface DeleteOneBaseProjectVersionControllerProjectVersionEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntityParameters {
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @type {string}
		 */
		s?: string
		/**
		 * @description <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		filter?: string[]
		/**
		 * @description <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		or?: string[]
		/**
		 * @description <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		sort?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		offset?: number
		/**
		 * @description <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @type {number}
		 */
		page?: number
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetManyBaseProjectVersionControllerProjectVersionEntityResponse =
		| GetManyBaseProjectVersionControllerProjectVersionEntity200Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity400Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity401Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity403Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity404Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity409Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity422Response
		| GetManyBaseProjectVersionControllerProjectVersionEntity500Response
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetManyProjectVersionEntityResponseDto | Api.ProjectVersionEntity[]
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetManyBaseProjectVersionControllerProjectVersionEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntityParameters {
		id: string
		/**
		 * @description <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		fields?: string[]
		/**
		 * @description <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @type {string[]}
		 */
		join?: string[]
		/**
		 * @description <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @type {number}
		 * minimum: 0
		 * maximum: 1
		 */
		cache?: number
	}
	
	export type GetOneBaseProjectVersionControllerProjectVersionEntityResponse =
		| GetOneBaseProjectVersionControllerProjectVersionEntity200Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity400Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity401Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity403Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity404Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity409Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity422Response
		| GetOneBaseProjectVersionControllerProjectVersionEntity500Response
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ProjectVersionEntity
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity401Response {
		status: 401
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity403Response {
		status: 403
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity409Response {
		status: 409
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity422Response {
		status: 422
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
	export interface GetOneBaseProjectVersionControllerProjectVersionEntity500Response {
		status: 500
		contentType: 'application/json'
		body: Api.ApiErrorResponseDto
		headers?: undefined
	}
	
}

/**
 * ProjectVersionApi - fetch parameter creator
 * @export
 */
export const ProjectVersionApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectVersionEntity
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseProjectVersionControllerProjectVersionEntity.');
			}

			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single ProjectVersionEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseProjectVersionControllerProjectVersionEntity.');
			}

			let localVarPath = `/project-version/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple ProjectVersionEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.s !== undefined) {
				localVarQueryParameter.append('s', String(__params.s));
			}

			if (__params.filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.page !== undefined) {
				localVarQueryParameter.append('page', String(__params.page));
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single ProjectVersionEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (__params.id === null || __params.id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseProjectVersionControllerProjectVersionEntity.');
			}

			let localVarPath = `/project-version/{id}`
				.replace('{id}', encodeURIComponent(String(__params.id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', __params.fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (__params.join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of __params.join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (__params.cache !== undefined) {
				localVarQueryParameter.append('cache', String(__params.cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectVersionApi - functional programming interface
 * @export
 */
export const ProjectVersionApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectVersionEntity
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.CreateOneBaseProjectVersionControllerProjectVersionEntityResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).createOneBaseProjectVersionControllerProjectVersionEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 201) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ProjectVersionEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Delete a single ProjectVersionEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.DeleteOneBaseProjectVersionControllerProjectVersionEntityResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: response.status,
						/* No content */
					}
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve multiple ProjectVersionEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).getManyBaseProjectVersionControllerProjectVersionEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.GetManyProjectVersionEntityResponseDto | Api.ProjectVersionEntity[],
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @summary Retrieve a single ProjectVersionEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityResponse> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).getOneBaseProjectVersionControllerProjectVersionEntity(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ProjectVersionEntity,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 401) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 403) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 409) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 422) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				if (response.status === 500) {
					if (mimeType === 'application/json') {
						return {
							status: response.status,
							contentType: 'application/json',
							body: await response.json() as Api.ApiErrorResponseDto,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * ProjectVersionApi - factory interface
 * @export
 */
export const ProjectVersionApiFactory: FactoryFunction<ProjectVersionApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectVersionApi(configuration, basePath, fetch);
};

/**
 * ProjectVersionApi - interface
 * @export
 * @interface ProjectVersionApi
 */
export interface ProjectVersionApiInterface {
	/**
	 * @summary Create a single ProjectVersionEntity
	 * @param {Api.ProjectVersionEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options?: RequestInit): Promise<ProjectVersionApi.CreateOneBaseProjectVersionControllerProjectVersionEntityResponse>

	/**
	 * @summary Delete a single ProjectVersionEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RequestInit): Promise<ProjectVersionApi.DeleteOneBaseProjectVersionControllerProjectVersionEntityResponse>

	/**
	 * @summary Retrieve multiple ProjectVersionEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getManyBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit): Promise<ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityResponse>

	/**
	 * @summary Retrieve a single ProjectVersionEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOneBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit): Promise<ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityResponse>

}

/**
 * ProjectVersionApi - object-oriented interface
 * @export
 * @class ProjectVersionApi
 * @extends {BaseAPI}
 */
export class ProjectVersionApi extends BaseAPI implements ProjectVersionApiInterface {
	/**
	 * @summary Create a single ProjectVersionEntity
	 * @param {Api.ProjectVersionEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).createOneBaseProjectVersionControllerProjectVersionEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single ProjectVersionEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple ProjectVersionEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetManyBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).getManyBaseProjectVersionControllerProjectVersionEntity(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single ProjectVersionEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseProjectVersionControllerProjectVersionEntity(__params: ProjectVersionApi.GetOneBaseProjectVersionControllerProjectVersionEntityParameters, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).getOneBaseProjectVersionControllerProjectVersionEntity(__params, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
