/* eslint-disable */
// tslint:disable
/**
 * gameguild.gg
 * 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/auth/me`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerGetWeb3SignInChallenge.');
			}
			let localVarPath = `/auth/web3/sign-in/challenge`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.LocalSignInDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerLocalSignWithEmailOrUsername.');
			}
			let localVarPath = `/auth/local/sign-in`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerMagicLink.');
			}
			let localVarPath = `/auth/magic-link`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/auth/refresh-token`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'token' is not null or undefined
			if (token === null || token === undefined) {
				throw new RequiredError('token', 'Required parameter token was null or undefined when calling authControllerSignInWithGoogle.');
			}
			let localVarPath = `/auth/google/callback/{token}`
				.replace('{token}', encodeURIComponent(String(token)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerSignUpWithEmailUsernamePassword.');
			}
			let localVarPath = `/auth/local/sign-up`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'user' is not null or undefined
			if (user === null || user === undefined) {
				throw new RequiredError('user', 'Required parameter user was null or undefined when calling authControllerUserExists.');
			}
			let localVarPath = `/auth/userExists/{user}`
				.replace('{user}', encodeURIComponent(String(user)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling authControllerValidateWeb3SignInChallenge.');
			}
			let localVarPath = `/auth/web3/sign-in/validate`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetCurrentUser(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.UserEntity> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetCurrentUser(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.EthereumSigninChallengeRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.EthereumSigninChallengeResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerGetWeb3SignInChallenge(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.LocalSignInDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.LocalSignInResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerLocalSignWithEmailOrUsername(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.EmailDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerMagicLink(request: Api.EmailDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.OkDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerMagicLink(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerRefreshToken(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.LocalSignInResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerRefreshToken(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {string} token
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignInWithGoogle(token: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.LocalSignInResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignInWithGoogle(token, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							throw response;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.LocalSignUpDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.LocalSignInResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerSignUpWithEmailUsernamePassword(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {string} user
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerUserExists(user: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerUserExists(user, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.EthereumSigninValidateRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.LocalSignInResponseDto> {
			const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerValidateWeb3SignInChallenge(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory: FactoryFunction<AuthApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new AuthApi(configuration, basePath, fetch);
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetCurrentUser(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetCurrentUser(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninChallengeRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerGetWeb3SignInChallenge(request: Api.EthereumSigninChallengeRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerGetWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.LocalSignInDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerLocalSignWithEmailOrUsername(request: Api.LocalSignInDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerLocalSignWithEmailOrUsername(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EmailDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerMagicLink(request: Api.EmailDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerMagicLink(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerRefreshToken(options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerRefreshToken(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} token
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignInWithGoogle(token: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignInWithGoogle(token, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.LocalSignUpDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerSignUpWithEmailUsernamePassword(request: Api.LocalSignUpDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerSignUpWithEmailUsernamePassword(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} user
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerUserExists(user: string, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerUserExists(user, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EthereumSigninValidateRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public authControllerValidateWeb3SignInChallenge(request: Api.EthereumSigninValidateRequestDto, options?: RequestInit) {
		return AuthApiFp(this.configuration).authControllerValidateWeb3SignInChallenge(request, options)(this.fetch, this.basePath);
	}

}
/**
 * CompetitionsApi - fetch parameter creator
 * @export
 */
export const CompetitionsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerFindChessMatchResult.');
			}
			let localVarPath = `/Competitions/Chess/FindMatches`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/Competitions/Chess/Leaderboard`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling competitionControllerGetChessMatchResult.');
			}
			let localVarPath = `/Competitions/Chess/Match/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/Competitions/Chess/LatestCompetitionReport`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/Competitions/Chess/ListAgents`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRequestChessMove.');
			}
			let localVarPath = `/Competitions/Chess/Move`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling competitionControllerRunChessMatch.');
			}
			let localVarPath = `/Competitions/Chess/RunMatch`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/Competitions/Chess/RunCompetition`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/Competitions/Chess/submit`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'multipart/form-data');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				const localVarFormData = new FormData();
				if (request.file !== undefined) {
					localVarFormData.append('file', request.file.value);
				}
				localVarRequestOptions.body = localVarFormData;
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * CompetitionsApi - functional programming interface
 * @export
 */
export const CompetitionsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.MatchSearchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.MatchSearchResponseDto[]> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerFindChessMatchResult(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 204) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessLeaderboard(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ChessLeaderboardResponseEntryDto[]> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessLeaderboard(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 204) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetChessMatchResult(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ChessMatchResultDto> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetChessMatchResult(id, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerGetLatestChessCompetitionReport(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CompetitionRunSubmissionReportEntity[]> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerGetLatestChessCompetitionReport(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 204) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerListChessAgents(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<string[]> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerListChessAgents(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 204) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.ChessMoveRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRequestChessMove(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.ChessMatchRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ChessMatchResultDto> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunChessMatch(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerRunCompetition(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerRunCompetition(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.TerminalDto[]> {
			const localVarFetchArgs = CompetitionsApiFetchParamCreator(configuration).competitionControllerSubmitChessAgent(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * CompetitionsApi - factory interface
 * @export
 */
export const CompetitionsApiFactory: FactoryFunction<CompetitionsApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new CompetitionsApi(configuration, basePath, fetch);
};

/**
 * CompetitionsApi - object-oriented interface
 * @export
 * @class CompetitionsApi
 * @extends {BaseAPI}
 */
export class CompetitionsApi extends BaseAPI {
	/**
	 * @param {Api.MatchSearchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerFindChessMatchResult(request: Api.MatchSearchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerFindChessMatchResult(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessLeaderboard(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessLeaderboard(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetChessMatchResult(id: string, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetChessMatchResult(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerGetLatestChessCompetitionReport(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerGetLatestChessCompetitionReport(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerListChessAgents(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerListChessAgents(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMoveRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRequestChessMove(request: Api.ChessMoveRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRequestChessMove(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.ChessMatchRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunChessMatch(request: Api.ChessMatchRequestDto, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunChessMatch(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerRunCompetition(options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerRunCompetition(options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.CompetitionSubmissionDto.MultipartFormData} [request]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public competitionControllerSubmitChessAgent(request: Api.CompetitionSubmissionDto.MultipartFormData | undefined, options?: RequestInit) {
		return CompetitionsApiFp(this.configuration).competitionControllerSubmitChessAgent(request, options)(this.fetch, this.basePath);
	}

}
/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/content/course/create`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		contentControllerCreateEmptyCourse(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CourseEntity> {
			const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentControllerCreateEmptyCourse(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory: FactoryFunction<ContentApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ContentApi(configuration, basePath, fetch);
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public contentControllerCreateEmptyCourse(options?: RequestInit) {
		return ContentApiFp(this.configuration).contentControllerCreateEmptyCourse(options)(this.fetch, this.basePath);
	}

}
/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectEntity
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseProjectControllerProjectEntity.');
			}
			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single ProjectEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectControllerProjectEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseProjectControllerProjectEntity.');
			}
			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple ProjectEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectControllerProjectEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/project`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (s !== undefined) {
				localVarQueryParameter.append('s', String(s));
			}

			if (filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			if (page !== undefined) {
				localVarQueryParameter.append('page', String(page));
			}

			if (cache !== undefined) {
				localVarQueryParameter.append('cache', String(cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single ProjectEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectControllerProjectEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseProjectControllerProjectEntity.');
			}
			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (cache !== undefined) {
				localVarQueryParameter.append('cache', String(cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerAddEditor.');
			}
			let localVarPath = `/project/add-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerRemoveEditor.');
			}
			let localVarPath = `/project/remove-editor`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling projectControllerSwitchOwner.');
			}
			let localVarPath = `/project/transfer-ownership`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update a single ProjectEntity
		 * @param {string} id
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOneBaseProjectControllerProjectEntity.');
			}
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateOneBaseProjectControllerProjectEntity.');
			}
			let localVarPath = `/project/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PATCH' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectEntity
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ProjectEntity> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).createOneBaseProjectControllerProjectEntity(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Delete a single ProjectEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectControllerProjectEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).deleteOneBaseProjectControllerProjectEntity(id, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Retrieve multiple ProjectEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectControllerProjectEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetManyProjectEntityResponseDto | Api.ProjectEntity[]> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getManyBaseProjectControllerProjectEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Retrieve a single ProjectEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectControllerProjectEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ProjectEntity> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).getOneBaseProjectControllerProjectEntity(id, fields, join, cache, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerAddEditor(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.EditorRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerRemoveEditor(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @param {Api.TransferOwnershipRequestDto} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectControllerSwitchOwner(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Update a single ProjectEntity
		 * @param {string} id
		 * @param {Api.ProjectEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ProjectEntity> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).updateOneBaseProjectControllerProjectEntity(id, request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory: FactoryFunction<ProjectApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectApi(configuration, basePath, fetch);
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
	/**
	 * @summary Create a single ProjectEntity
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseProjectControllerProjectEntity(request: Api.ProjectEntity, options?: RequestInit) {
		return ProjectApiFp(this.configuration).createOneBaseProjectControllerProjectEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single ProjectEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseProjectControllerProjectEntity(id: string, options?: RequestInit) {
		return ProjectApiFp(this.configuration).deleteOneBaseProjectControllerProjectEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple ProjectEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseProjectControllerProjectEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options?: RequestInit) {
		return ProjectApiFp(this.configuration).getManyBaseProjectControllerProjectEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single ProjectEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseProjectControllerProjectEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options?: RequestInit) {
		return ProjectApiFp(this.configuration).getOneBaseProjectControllerProjectEntity(id, fields, join, cache, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerAddEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerAddEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.EditorRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerRemoveEditor(request: Api.EditorRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerRemoveEditor(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {Api.TransferOwnershipRequestDto} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public projectControllerSwitchOwner(request: Api.TransferOwnershipRequestDto, options?: RequestInit) {
		return ProjectApiFp(this.configuration).projectControllerSwitchOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update a single ProjectEntity
	 * @param {string} id
	 * @param {Api.ProjectEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateOneBaseProjectControllerProjectEntity(id: string, request: Api.ProjectEntity, options?: RequestInit) {
		return ProjectApiFp(this.configuration).updateOneBaseProjectControllerProjectEntity(id, request, options)(this.fetch, this.basePath);
	}

}
/**
 * ProjectVersionApi - fetch parameter creator
 * @export
 */
export const ProjectVersionApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectVersionEntity
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOneBaseProjectVersionControllerProjectVersionEntity.');
			}
			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Delete a single ProjectVersionEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOneBaseProjectVersionControllerProjectVersionEntity.');
			}
			let localVarPath = `/project-version/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve multiple ProjectVersionEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectVersionControllerProjectVersionEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/project-version`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (s !== undefined) {
				localVarQueryParameter.append('s', String(s));
			}

			if (filter !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of filter) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('filter', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (or !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of or) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('or', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (sort !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of sort) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('sort', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			if (page !== undefined) {
				localVarQueryParameter.append('page', String(page));
			}

			if (cache !== undefined) {
				localVarQueryParameter.append('cache', String(cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Retrieve a single ProjectVersionEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOneBaseProjectVersionControllerProjectVersionEntity.');
			}
			let localVarPath = `/project-version/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication bearer required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('bearer')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (fields !== undefined) {
				/* array form */
				localVarQueryParameter.append('fields', fields.map(localVarArrayMapElement => escape(String(localVarArrayMapElement))).join(','));
			}

			if (join !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of join) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('join', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (cache !== undefined) {
				localVarQueryParameter.append('cache', String(cache));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProjectVersionApi - functional programming interface
 * @export
 */
export const ProjectVersionApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Create a single ProjectVersionEntity
		 * @param {Api.ProjectVersionEntity} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ProjectVersionEntity> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).createOneBaseProjectVersionControllerProjectVersionEntity(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 201) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Delete a single ProjectVersionEntity
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						return response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Retrieve multiple ProjectVersionEntities
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
		 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
		 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
		 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
		 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
		 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getManyBaseProjectVersionControllerProjectVersionEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetManyProjectVersionEntityResponseDto | Api.ProjectVersionEntity[]> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).getManyBaseProjectVersionControllerProjectVersionEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
		/**
		 * @summary Retrieve a single ProjectVersionEntity
		 * @param {string} id
		 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
		 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
		 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ProjectVersionEntity> {
			const localVarFetchArgs = ProjectVersionApiFetchParamCreator(configuration).getOneBaseProjectVersionControllerProjectVersionEntity(id, fields, join, cache, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					if (response.status === 401) {
						return response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * ProjectVersionApi - factory interface
 * @export
 */
export const ProjectVersionApiFactory: FactoryFunction<ProjectVersionApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProjectVersionApi(configuration, basePath, fetch);
};

/**
 * ProjectVersionApi - object-oriented interface
 * @export
 * @class ProjectVersionApi
 * @extends {BaseAPI}
 */
export class ProjectVersionApi extends BaseAPI {
	/**
	 * @summary Create a single ProjectVersionEntity
	 * @param {Api.ProjectVersionEntity} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createOneBaseProjectVersionControllerProjectVersionEntity(request: Api.ProjectVersionEntity, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).createOneBaseProjectVersionControllerProjectVersionEntity(request, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Delete a single ProjectVersionEntity
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOneBaseProjectVersionControllerProjectVersionEntity(id: string, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).deleteOneBaseProjectVersionControllerProjectVersionEntity(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve multiple ProjectVersionEntities
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string} [s] <p>Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a></p>
	 * @param {string[]} [filter] <p>Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a></p>
	 * @param {string[]} [or] <p>Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a></p>
	 * @param {string[]} [sort] <p>Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [limit] <p>Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a></p>
	 * @param {number} [offset] <p>Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a></p>
	 * @param {number} [page] <p>Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getManyBaseProjectVersionControllerProjectVersionEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).getManyBaseProjectVersionControllerProjectVersionEntity(fields, s, filter, or, sort, join, limit, offset, page, cache, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Retrieve a single ProjectVersionEntity
	 * @param {string} id
	 * @param {string[]} [fields] <p>Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a></p>
	 * @param {string[]} [join] <p>Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a></p>
	 * @param {number} [cache] <p>Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a></p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOneBaseProjectVersionControllerProjectVersionEntity(id: string, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined, options?: RequestInit) {
		return ProjectVersionApiFp(this.configuration).getOneBaseProjectVersionControllerProjectVersionEntity(id, fields, join, cache, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
