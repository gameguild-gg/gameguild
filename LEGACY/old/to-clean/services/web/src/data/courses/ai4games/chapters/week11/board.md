# Chess Board Representation

## Game State

The game state should contain the following information:

- Turn: which player's turn it is (white or black).
- Enpassant: the square where the en passant capture can be made.
- Castling: whether castling is possible for each player and which side.
- Full-move: the number of full moves made in the game.
- Half-move: the number of half moves made in the game. (50-move rule)
- History: the history of the game, including the moves made and the positions reached. Can be useful for detecting
  threefold repetition and for move generation.

``` c++
// needs 9 bits for the game state
PieceColor turn:1;       // 0-1: black or white
bool enpassant:1:        // 0-1: enpassant available or not
uint8_t enpassantFile:3; // 0-7: file of the enpassant square
uint8_t castling:4;      // castling rights bits: 0bKQkq
// all moves counter can be generated by analyzing the history, 
// so we can simply not store it
// uint8_t halfMove:7;   // 0-127: number of half moves made in the game
// uint16_t fullMove:     
```

## Square-centric approach

A naive approach for representing the chessboard is to use a 2D array of 8x8. Each square can be represented by a single
byte, where the first bit represents the color and the last three bits represent the piece type. This representation is
simple and easy to understand, but it is not very efficient in terms of memory usage and performance.

``` c++
// needs only 4 bits, and wastes 4 bits
struct Square {
    PieceColor color:1;
    PieceType  type:3;
};

// 64 bytes only for the pieces
struct Board {
    Square squares[8][8];
    // or 
    // Square squares[64];
};
```

A bit more efficient approach is to store 2 squares in a single byte. This way, we can represent the whole board in 32
bytes. However, we need to shift the bits to get the square.

``` c++
// 8x8 but with shifted bits
struct Board {
    // each byte represents 2 squares
    // we need to shift the bits to get the square
    uint8_t squares[32];
    
    // get the square at index i 0-64
    Square getSquare(int i) {
        // shift the bits to get the square
        return Square((squares[i/2] >> (i%2)*4) & 0b1111);
    }
    
    // set the square at index i 0-64
    void setSquare(int i, Square square) {
        // shift the bits to set the square
        squares[i/2] |= (square.color << (i%2)*4);
        squares[i/2] |= (square.type << ((i%2)*4 + 1));
    }
};
```

### Piece-centric approach

Another approach is to use a piece-centric representation, where we store the pieces in a list or a map. This way, we
can easily access the pieces and their positions on the board. However, this representation is not very efficient in
terms of memory usage and performance.

``` c++
// piece centric approach
// uses 2 bytes for each piece
struct Piece {
    PieceColor color:1; // 0-1: black or white
    PieceType type:3; // 0-7: pawn, knight, bishop, rook, queen, king
    uint8_t position:6; // 0-63: positions on the board
};

// consumes 88 bytes
struct Board {
    // vector consumes 24 bytes for capacity, size, and pointer
    // each piece consumes 2 bytes, we have 32, so 64 bytes
    std::vector<Piece> pieces;
    
    // get the piece at index i
    Piece getPiece(int i) {
        return pieces[i];
    }
};
```

## Bitboard approach

A more advanced approach is to use a bitboard representation, where we use a 64-bit integer to represent the board. Each
bit represents a square on the board, and we can use bitwise operations to manipulate the board. This representation is
very efficient in terms of performance, consumes more memory, but it is also more complex to implement.

``` c++
// bitboard approach
struct BitBoard {
    uint64_t data;
    
    // set the bit at index i
    void set(int i) {
        data |= (1ULL << i);
    }
    // clear the bit at index i
    void clear(int i) {
        data &= ~(1ULL << i);
    }
    // get the bit at index i
    bool get(int i) {
        return (data & (1ULL << i)) != 0;
    }
};

// 56 bytes for the board
struct Board {
    // 6 bitboards for each piece type
    // pawn, knight, bishop, rook, queen, king
    BitBoard pieceBoards[6];
    BitBoard colorBoard; // white if 1, black if 0
    
    // get the piece at index i
    Piece getPiece(int i) {
        Piece piece;
        piece.color = colorBoard.get(i) ? PieceColor::WHITE : PieceColor::BLACK;
        piece.type = (pieceBoards[0].data & (1ULL << i) ? PieceType::PAWN :
                      pieceBoards[1].data & (1ULL << i) ? PieceType::KNIGHT :
                      pieceBoards[2].data & (1ULL << i) ? PieceType::BISHOP :
                      pieceBoards[3].data & (1ULL << i) ? PieceType::ROOK :
                      pieceBoards[4].data & (1ULL << i) ? PieceType::QUEEN :
                      pieceBoards[5].data & (1ULL << i) ? PieceType::KING : PieceType::EMPTY);
        return piece;
    }
};
```

## Other Optimization techniques

### Huffman Coding

Huffman coding is a frequency-based compression algorithm that assigns variable-length codes to input characters based
on their frequencies. It is a lossless compression technique that is widely used in data compression applications. In
the context of chess, Huffman coding can be used to compress the representation of the board and pieces, reducing memory
usage and improving performance.

If we linearize a chess board into a 1D array, the initial state would be:

```
[ 
'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r', 
'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p',
' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P',
'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'
]
```

or if you use as string it would be:

```
"rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR"
```

I recommend first you to explore and visualize the Huffman coding algorithm. You can find a
good [visualization here](https://cmps-people.ok.ubc.ca/ylucet/DS/Huffman.html).

It is out of the scope of this class to explain Huffman coding. But the idea is to assign shorter codes to more frequent
pieces and longer codes to less frequent pieces. For example, we can assign the following codes:

``` c++
// Huffman codes for chess pieces
enum class PieceCode: std::uint8_t {
    EMPTY        = 0b0,      // 32x 
    WHITE_PAWN   = 0b100,    // 8x
    BLACK_PAWN   = 0b101,    // 8x
    BLACK_ROOK   = 0b11101,  // 2x
    BLACK_KNIGHT = 0b11100,  // 2x
    WHITE_ROOK   = 0b11110,  // 2x
    BLACK_BISHOP = 0b11111,  // 2x
    WHITE_KNIGHT = 0b11001,  // 2x
    WHITE_BISHOP = 0b11000,  // 2x
    BLACK_QUEEN  = 0b110101, // 1x
    WHITE_QUEEN  = 0b110111, // 1x
    BLACK_KING   = 0b110100, // 1x
    WHITE_KING   = 0B110110, // 1x
};
```

In this approach, we will need a dynamic sized array of to hold the total of `164` bits for the initial state, with the
average of `20.5` bytes per board. You will have to implement a encoder and decoder, and use and abuse the data layout
to store the data. But we can safely guestimate `24` bytes in the case of promotions.

::: warning "Warning"

This approach is only efficient for storing the state, not for querying, modifying or manipulating the board.

:::

### Zobrist Hashing

Zobrist hashing is a technique used to efficiently compute a hash value for a chess position. It uses a random number
for each piece type and color, and XORs them together to create a unique hash for the position. This allows for fast
comparisons of positions and can be used for transposition tables in chess engines. Read more about it
on [Chess Programming Wiki](https://www.chessprogramming.org/Zobrist_Hashing).

### Transposition Tables

Transposition tables are used to store previously computed positions and their evaluations. This allows the engine to
avoid recomputing the evaluation for the same position, improving performance. The transposition table can be
implemented using a hash table, where the key is the Zobrist hash of the position and the value is the evaluation of the
position. [Read more about it on Chess Programming Wiki](https://www.chessprogramming.org/Transposition_Table)
